<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Marcin Benke" />
  <title>Advanced Functional Programming</title>
  <style type="text/css">
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="https://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" />
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
  type="text/javascript"></script>
  <script src="https://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Advanced Functional Programming</h1>
  <p class="subtitle">Testing</p>
  <p class="author">
Marcin Benke
  </p>
  <p class="date">Mar 4, 2025</p>
</div>
<div class="slide section level1">

<meta name="duration" content="80" />
</div>
<div id="testing-haskell-programs" class="slide section level1">
<h1>Testing Haskell Programs</h1>
<ul>
<li>doctest <a href="https://github.com/sol/doctest">github:
sol/doctest</a></li>
<li>HUnit</li>
<li>Quickcheck</li>
<li>QuickCheck + doctest
<!-- * Hedgehog [github: hedgehogqa/haskell-hedgehog](https://github.com/hedgehogqa/haskell-hedgehog)
--></li>
</ul>
</div>
<div id="doctest" class="slide section level1">
<h1>doctest</h1>
<p>Examples in the docs can be used as regression tests</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="kw">module</span> <span class="dt">DoctestExamples</span> <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="co">-- | Expect success</span></span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="co">-- &gt;&gt;&gt; 2 + 2</span></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="co">-- 4</span></span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a><span class="co">-- | Expect failure</span></span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a><span class="co">-- &gt;&gt;&gt; 2 + 2</span></span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a><span class="co">-- 5</span></span></code></pre></div>
<pre><code>$ stack install doctest
$ stack exec doctest DoctestExamples.hs
### Failure in DoctestExamples.hs:7: expression `2 + 2&#39;
expected: 5
 but got: 4
Examples: 2  Tried: 2  Errors: 0  Failures: 1</code></pre>
</div>
<div id="an-example-from-bnfc" class="slide section level1">
<h1>An Example from BNFC</h1>
<div class="sourceCode" id="cb3"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="co">-- | Generate a name in the given case style taking into account the reserved</span></span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a><span class="co">-- word of the language.</span></span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a><span class="co">-- &gt;&gt;&gt; mkName [] SnakeCase &quot;FooBAR&quot;</span></span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a><span class="co">-- &quot;foo_bar&quot;</span></span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a><span class="co">-- &gt;&gt;&gt; mkName [] CamelCase &quot;FooBAR&quot;</span></span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a><span class="co">-- &quot;FooBAR&quot;</span></span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a><span class="co">-- &gt;&gt;&gt; mkName [] CamelCase &quot;Foo_bar&quot;</span></span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a><span class="co">-- &quot;FooBar&quot;</span></span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a><span class="co">-- &gt;&gt;&gt; mkName [&quot;foobar&quot;] LowerCase &quot;FooBAR&quot;</span></span>
<span id="cb3-10"><a href="#cb3-10" tabindex="-1"></a><span class="co">-- &quot;foobar_&quot;</span></span>
<span id="cb3-11"><a href="#cb3-11" tabindex="-1"></a><span class="ot">mkName ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">NameStyle</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb3-12"><a href="#cb3-12" tabindex="-1"></a>mkName reserved style s <span class="ot">=</span> <span class="op">...</span></span></code></pre></div>
</div>
<div id="digression---haddock" class="slide section level1">
<h1>Digression - Haddock</h1>
<p>Haddock (<a href="http://haskell.org/haddock"
class="uri">http://haskell.org/haddock</a>) is a commonly used Haskell
documentation tool.</p>
<p>The sequence <code>{-|</code> or <code>-- |</code> (space is
important) starts a comment block, which is passed to documentation</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="co">-- | The &#39;square&#39; function squares an integer.</span></span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a><span class="co">-- It takes one argument, of type &#39;Int&#39;.</span></span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a><span class="ot">square ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a>square x <span class="ot">=</span> x <span class="op">*</span> x</span></code></pre></div>
<pre><code>$ haddock --html Square.hs</code></pre>
</div>
<div id="hunit" class="slide section level1">
<h1>HUnit</h1>
<p>Unit tests are a common practice in many languages</p>
<p>We can do that in Haskell as well, e.g.:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Test.HUnit</span></span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a><span class="kw">import</span> <span class="dt">MyArray</span></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a>main <span class="ot">=</span> runTestTT tests</span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a>tests <span class="ot">=</span> <span class="dt">TestList</span> [test1,test2]</span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a>listArray1 es <span class="ot">=</span> listArray (<span class="dv">1</span>,<span class="fu">length</span> es) es</span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a>test1 <span class="ot">=</span> <span class="dt">TestCase</span><span class="op">$</span>assertEqual <span class="st">&quot;a!2 = 2&quot;</span> (listArray1 [<span class="dv">1</span><span class="op">..</span><span class="dv">3</span>] <span class="op">!</span> <span class="dv">2</span>) <span class="dv">2</span></span>
<span id="cb6-10"><a href="#cb6-10" tabindex="-1"></a>test2 <span class="ot">=</span> <span class="dt">TestCase</span><span class="op">$</span>assertEqual <span class="st">&quot;elems . array = id&quot;</span></span>
<span id="cb6-11"><a href="#cb6-11" tabindex="-1"></a>                             (elems <span class="op">$</span> listArray1 [<span class="dv">1</span><span class="op">..</span><span class="dv">3</span>]) [<span class="dv">1</span><span class="op">..</span><span class="dv">3</span>]</span></code></pre></div>
<pre><code>&gt; main
Cases: 2  Tried: 2  Errors: 0  Failures: 0
Counts {cases = 2, tried = 2, errors = 0, failures = 0}</code></pre>
</div>
<div id="lets-sort-a-list" class="slide section level1">
<h1>Let’s sort a list</h1>
<div class="sourceCode" id="cb8"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="ot">mergeSort ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a>mergeSort <span class="fu">pred</span> <span class="ot">=</span> go</span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a>    go []  <span class="ot">=</span> []</span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a>    go [x] <span class="ot">=</span> [x]</span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a>    go xs  <span class="ot">=</span> merge (go xs1) (go xs2)</span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a>      <span class="kw">where</span> (xs1,xs2) <span class="ot">=</span> split xs</span>
<span id="cb8-8"><a href="#cb8-8" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" tabindex="-1"></a>    merge xs [] <span class="ot">=</span> xs</span>
<span id="cb8-10"><a href="#cb8-10" tabindex="-1"></a>    merge [] ys <span class="ot">=</span> ys</span>
<span id="cb8-11"><a href="#cb8-11" tabindex="-1"></a>    merge (x<span class="op">:</span>xs) (y<span class="op">:</span>ys)</span>
<span id="cb8-12"><a href="#cb8-12" tabindex="-1"></a>      <span class="op">|</span> <span class="fu">pred</span> x y  <span class="ot">=</span> x <span class="op">:</span> merge xs (y<span class="op">:</span>ys)</span>
<span id="cb8-13"><a href="#cb8-13" tabindex="-1"></a>      <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> y <span class="op">:</span> merge (x<span class="op">:</span>xs) ys</span>
<span id="cb8-14"><a href="#cb8-14" tabindex="-1"></a></span>
<span id="cb8-15"><a href="#cb8-15" tabindex="-1"></a>    split []       <span class="ot">=</span> ([],[])</span>
<span id="cb8-16"><a href="#cb8-16" tabindex="-1"></a>    split [x]      <span class="ot">=</span> ([x],[])</span>
<span id="cb8-17"><a href="#cb8-17" tabindex="-1"></a>    split (x<span class="op">:</span>y<span class="op">:</span>zs) <span class="ot">=</span> (x<span class="op">:</span>xs,y<span class="op">:</span>ys)</span>
<span id="cb8-18"><a href="#cb8-18" tabindex="-1"></a>      <span class="kw">where</span> (xs,ys) <span class="ot">=</span> split zs</span></code></pre></div>
</div>
<div id="sorting-unit-tests" class="slide section level1">
<h1>Sorting: unit tests</h1>
<pre><code>sort = mergeSort ((&lt;=) :: Int -&gt; Int -&gt; Bool)

sort [1,2,3,4] == [1,2,3,4]
sort [4,3,2,1] == [1,2,3,4]
sort [1,4,2,3] == [1,2,3,4]
...</code></pre>
<p>It starts getting boring…</p>
<p>…but, thanks to types, we can do better</p>
</div>
<div id="properties" class="slide section level1">
<h1>Properties</h1>
<p>An obvious sorting property:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a>prop_idempotent <span class="ot">=</span> <span class="fu">sort</span> <span class="op">.</span> <span class="fu">sort</span> <span class="op">==</span> <span class="fu">sort</span></span></code></pre></div>
<p>is not definable; we cannot compare functions.</p>
<p>We can “cheat”:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>prop_idempotent xs <span class="ot">=</span></span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>    <span class="fu">sort</span> (<span class="fu">sort</span> xs) <span class="op">==</span> <span class="fu">sort</span> xs</span></code></pre></div>
<p>Let’s try it in REPL:</p>
<pre><code>*Main&gt; prop_idempotent [3,2,1]
True</code></pre>
</div>
<div id="an-automation-attempt" class="slide section level1">
<h1>An automation attempt</h1>
<p>We can try to automate it:</p>
<pre><code>prop_permute :: ([a] -&gt; Bool) -&gt; [a] -&gt; Bool
prop_permute prop = all prop . permutations

*Main&gt; prop_permute prop_idempotent [1,2,3]
True
*Main&gt; prop_permute prop_idempotent [1..4]
True
*Main&gt; prop_permute prop_idempotent [1..5]
True
*Main&gt; prop_permute prop_idempotent [1..10]
  C-c C-cInterrupted.

prop_permute&#39; prop xs = forAll (permutations xs) prop
  where forAll = flip all</code></pre>
</div>
<div id="quickcheck" class="slide section level1">
<h1>QuickCheck</h1>
<ul>
<li><p>Generating many unit tests is boring</p></li>
<li><p>Checking all possibilities is not realistic (except for small
data - see SmallCheck)</p></li>
<li><p>Idea: generate an appropriate random sample of the data</p></li>
</ul>
<pre><code>*Main&gt; import Test.QuickCheck
*Main Test.QuickCheck&gt; quickCheck prop_idempotent
+++ OK, passed 100 tests.</code></pre>
<p>QuickCheck generated 100 random lists and checked the property</p>
<p>Of course we can wish for 1000 instead of 100:</p>
<pre><code>*Main Test.QuickCheck&gt; quickCheckWith stdArgs {maxSuccess = 1000}  prop_idempotent
+++ OK, passed 1000 tests.</code></pre>
<p>NB: we cannot generate random “polymorphic values”, hence
<code>prop_idempotent</code> is monomorphic.</p>
<p><strong>Exercise:</strong> write and run a few tests for sorting and
your own functions.</p>
</div>
<div id="how-does-it-work" class="slide section level1">
<h1>How does it work?</h1>
<p>For simplicity, let’s look at QC v1</p>
<p>Main ingredients:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a><span class="ot">quickCheck  ::</span> <span class="dt">Testable</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Testable</span> a <span class="kw">where</span></span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a><span class="ot">  property ::</span> a <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb16-5"><a href="#cb16-5" tabindex="-1"></a>  <span class="co">-- the Property type will be explained later</span></span>
<span id="cb16-6"><a href="#cb16-6" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Testable</span> <span class="dt">Bool</span> <span class="kw">where</span><span class="op">...</span></span>
<span id="cb16-8"><a href="#cb16-8" tabindex="-1"></a></span>
<span id="cb16-9"><a href="#cb16-9" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Arbitrary</span> a, <span class="dt">Show</span> a, <span class="dt">Testable</span> b) <span class="ot">=&gt;</span> <span class="dt">Testable</span> (a <span class="ot">-&gt;</span> b) <span class="kw">where</span></span>
<span id="cb16-10"><a href="#cb16-10" tabindex="-1"></a>  property f <span class="ot">=</span> forAll arbitrary f</span>
<span id="cb16-11"><a href="#cb16-11" tabindex="-1"></a></span>
<span id="cb16-12"><a href="#cb16-12" tabindex="-1"></a><span class="co">-- forAll :: (Show a, Testable b) =&gt; Gen a -&gt; (a -&gt; b) -&gt; Property</span></span>
<span id="cb16-13"><a href="#cb16-13" tabindex="-1"></a></span>
<span id="cb16-14"><a href="#cb16-14" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Arbitrary</span> a <span class="kw">where</span></span>
<span id="cb16-15"><a href="#cb16-15" tabindex="-1"></a><span class="ot">  arbitrary   ::</span> <span class="dt">Gen</span> a</span>
<span id="cb16-16"><a href="#cb16-16" tabindex="-1"></a></span>
<span id="cb16-17"><a href="#cb16-17" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Gen</span> <span class="kw">where</span> <span class="op">...</span></span></code></pre></div>
<p><code>Gen</code> is a monad: <code>Gen t</code> is a computation
producing <code>t</code> (possibly using random generators).</p>
</div>
<div id="random-number-generation" class="slide section level1">
<h1>Random number generation</h1>
<div class="sourceCode" id="cb17"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.Random</span></span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a>  ( <span class="dt">StdGen</span>       <span class="co">-- :: *</span></span>
<span id="cb17-3"><a href="#cb17-3" tabindex="-1"></a>  , newStdGen    <span class="co">-- :: IO StdGen</span></span>
<span id="cb17-4"><a href="#cb17-4" tabindex="-1"></a>  , randomR      <span class="co">-- :: (RandomGen g, Random a) =&gt; (a, a) -&gt; g -&gt; (a, g)</span></span>
<span id="cb17-5"><a href="#cb17-5" tabindex="-1"></a>  , split        <span class="co">-- :: RandomGen g =&gt; g -&gt; (g, g)</span></span>
<span id="cb17-6"><a href="#cb17-6" tabindex="-1"></a>                 <span class="co">-- splits its argument into independent generators</span></span>
<span id="cb17-7"><a href="#cb17-7" tabindex="-1"></a>  <span class="co">-- class RandomGen where</span></span>
<span id="cb17-8"><a href="#cb17-8" tabindex="-1"></a>  <span class="co">--   next     :: g -&gt; (Int, g)</span></span>
<span id="cb17-9"><a href="#cb17-9" tabindex="-1"></a>  <span class="co">--   split    :: g -&gt; (g, g)</span></span>
<span id="cb17-10"><a href="#cb17-10" tabindex="-1"></a>  <span class="co">-- instance RandomGen StdGen</span></span>
<span id="cb17-11"><a href="#cb17-11" tabindex="-1"></a>  <span class="co">-- instance Random Int</span></span>
<span id="cb17-12"><a href="#cb17-12" tabindex="-1"></a>  )</span>
<span id="cb17-13"><a href="#cb17-13" tabindex="-1"></a></span>
<span id="cb17-14"><a href="#cb17-14" tabindex="-1"></a><span class="ot">roll ::</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb17-15"><a href="#cb17-15" tabindex="-1"></a>roll rnd <span class="ot">=</span> <span class="fu">fst</span> <span class="op">$</span> randomR (<span class="dv">1</span>,<span class="dv">6</span>) rnd</span>
<span id="cb17-16"><a href="#cb17-16" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb17-17"><a href="#cb17-17" tabindex="-1"></a>  rnd <span class="ot">&lt;-</span> newStdGen</span>
<span id="cb17-18"><a href="#cb17-18" tabindex="-1"></a>  <span class="kw">let</span> (r1,r2) <span class="ot">=</span> split rnd</span>
<span id="cb17-19"><a href="#cb17-19" tabindex="-1"></a>  <span class="fu">print</span> (roll r1)</span>
<span id="cb17-20"><a href="#cb17-20" tabindex="-1"></a>  <span class="fu">print</span> (roll r2)</span>
<span id="cb17-21"><a href="#cb17-21" tabindex="-1"></a>  <span class="fu">print</span> (roll r1)</span>
<span id="cb17-22"><a href="#cb17-22" tabindex="-1"></a>  <span class="fu">print</span> (roll r2)</span></code></pre></div>
<pre><code>*Main System.Random&gt; main
4
5
4
5</code></pre>
</div>
<div id="random-object-generation" class="slide section level1">
<h1>Random object generation</h1>
<p><code>Gen</code> is a monad: <code>Gen t</code> is a computation
producing <code>t</code> (possibly using random generators).</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a><span class="ot">choose ::</span> (<span class="dt">Int</span>,<span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Gen</span> <span class="dt">Int</span>   <span class="co">-- uniform over a range</span></span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a><span class="ot">oneof ::</span> [<span class="dt">Gen</span> a] <span class="ot">-&gt;</span> <span class="dt">Gen</span> a        <span class="co">-- choose random gen from the list</span></span>
<span id="cb19-3"><a href="#cb19-3" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Int</span> <span class="kw">where</span> <span class="co">-- we&#39;ll have a better gen in a moment</span></span>
<span id="cb19-5"><a href="#cb19-5" tabindex="-1"></a>    arbitrary <span class="ot">=</span> choose (<span class="op">-</span><span class="dv">100</span>, <span class="dv">100</span>)</span>
<span id="cb19-6"><a href="#cb19-6" tabindex="-1"></a></span>
<span id="cb19-7"><a href="#cb19-7" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Colour</span> <span class="ot">=</span> <span class="dt">Red</span> <span class="op">|</span> <span class="dt">Green</span> <span class="op">|</span> <span class="dt">Blue</span></span>
<span id="cb19-8"><a href="#cb19-8" tabindex="-1"></a></span>
<span id="cb19-9"><a href="#cb19-9" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Colour</span> <span class="kw">where</span></span>
<span id="cb19-10"><a href="#cb19-10" tabindex="-1"></a>    arbitrary <span class="ot">=</span> oneof [<span class="fu">return</span> <span class="dt">Red</span>, <span class="fu">return</span> <span class="dt">Green</span>, <span class="fu">return</span> <span class="dt">Blue</span>]</span>
<span id="cb19-11"><a href="#cb19-11" tabindex="-1"></a></span>
<span id="cb19-12"><a href="#cb19-12" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> a <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> [a] <span class="kw">where</span></span>
<span id="cb19-13"><a href="#cb19-13" tabindex="-1"></a>    arbitrary <span class="ot">=</span> oneof [<span class="fu">return</span> [], liftM2 (<span class="op">:</span>) arbitrary arbitrary]</span>
<span id="cb19-14"><a href="#cb19-14" tabindex="-1"></a></span>
<span id="cb19-15"><a href="#cb19-15" tabindex="-1"></a><span class="ot">generate ::</span> <span class="dt">Gen</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span></code></pre></div>
<p>What is the expected value of the length of a random list generated
this way?</p>
<p><span class="math display">\[ \sum_{n=0}^\infty {n\over 2^{n+1}} = 1
\]</span></p>
</div>
<div id="adjusting-distribution" class="slide section level1">
<h1>Adjusting distribution:</h1>
<div class="sourceCode" id="cb20"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a><span class="ot">frequency ::</span> [(<span class="dt">Int</span>, <span class="dt">Gen</span> a)] <span class="ot">-&gt;</span> <span class="dt">Gen</span> a  <span class="co">-- weighted distribution</span></span>
<span id="cb20-2"><a href="#cb20-2" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> a <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> [a] <span class="kw">where</span></span>
<span id="cb20-4"><a href="#cb20-4" tabindex="-1"></a>  arbitrary <span class="ot">=</span> frequency</span>
<span id="cb20-5"><a href="#cb20-5" tabindex="-1"></a>    [ (<span class="dv">1</span>, <span class="fu">return</span> [])</span>
<span id="cb20-6"><a href="#cb20-6" tabindex="-1"></a>    , (<span class="dv">4</span>, liftM2 (<span class="op">:</span>) arbitrary arbitrary)</span>
<span id="cb20-7"><a href="#cb20-7" tabindex="-1"></a>    ]</span>
<span id="cb20-8"><a href="#cb20-8" tabindex="-1"></a></span>
<span id="cb20-9"><a href="#cb20-9" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Tree</span> a <span class="ot">=</span> <span class="dt">Leaf</span> a <span class="op">|</span> <span class="dt">Branch</span> (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)</span>
<span id="cb20-10"><a href="#cb20-10" tabindex="-1"></a></span>
<span id="cb20-11"><a href="#cb20-11" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> a <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (<span class="dt">Tree</span> a) <span class="kw">where</span></span>
<span id="cb20-12"><a href="#cb20-12" tabindex="-1"></a>    arbitrary <span class="ot">=</span> frequency</span>
<span id="cb20-13"><a href="#cb20-13" tabindex="-1"></a>        [(<span class="dv">1</span>, liftM <span class="dt">Leaf</span> arbitrary)</span>
<span id="cb20-14"><a href="#cb20-14" tabindex="-1"></a>        ,(<span class="dv">2</span>, liftM2 <span class="dt">Branch</span> arbitrary arbitrary)</span>
<span id="cb20-15"><a href="#cb20-15" tabindex="-1"></a>        ]</span>
<span id="cb20-16"><a href="#cb20-16" tabindex="-1"></a></span>
<span id="cb20-17"><a href="#cb20-17" tabindex="-1"></a><span class="ot">threetrees ::</span> <span class="dt">Gen</span> [<span class="dt">Tree</span> <span class="dt">Int</span>]</span>
<span id="cb20-18"><a href="#cb20-18" tabindex="-1"></a>threetrees <span class="ot">=</span> <span class="fu">sequence</span> [arbitrary, arbitrary, arbitrary]</span></code></pre></div>
<p>what is the probability that generating a tree ever stops?</p>
<p><span class="math display">\[ p = {1\over 3} + {2\over 3} p^2
\]</span></p>
<p><span class="math display">\[ p = 1/2 \]</span></p>
<p>For <code>threetrees</code> it’s only 1/8</p>
</div>
<div id="limiting-size" class="slide section level1">
<h1>Limiting size</h1>
<div class="sourceCode" id="cb21"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a><span class="co">-- A generator given the desired size and an StdGen yields an a</span></span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Gen</span> a <span class="ot">=</span> <span class="dt">Gen</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> a)</span>
<span id="cb21-3"><a href="#cb21-3" tabindex="-1"></a></span>
<span id="cb21-4"><a href="#cb21-4" tabindex="-1"></a><span class="ot">chooseInt1 ::</span> (<span class="dt">Int</span>,<span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Gen</span> <span class="dt">Int</span></span>
<span id="cb21-5"><a href="#cb21-5" tabindex="-1"></a>chooseInt1 bounds <span class="ot">=</span> <span class="dt">Gen</span> <span class="op">$</span> \n r  <span class="ot">-&gt;</span> <span class="fu">fst</span> (randomR bounds r)</span>
<span id="cb21-6"><a href="#cb21-6" tabindex="-1"></a><span class="co">-- randomR :: (Random a) =&gt; (a, a) -&gt; StdGen -&gt; (a, StdGen)</span></span>
<span id="cb21-7"><a href="#cb21-7" tabindex="-1"></a></span>
<span id="cb21-8"><a href="#cb21-8" tabindex="-1"></a><span class="co">-- | `sized` builds a generator from a size-indexed generator family</span></span>
<span id="cb21-9"><a href="#cb21-9" tabindex="-1"></a><span class="ot">sized ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> a) <span class="ot">-&gt;</span> <span class="dt">Gen</span> a</span>
<span id="cb21-10"><a href="#cb21-10" tabindex="-1"></a>sized fgen <span class="ot">=</span> <span class="dt">Gen</span> (\n r <span class="ot">-&gt;</span> <span class="kw">let</span> <span class="dt">Gen</span> m <span class="ot">=</span> fgen n <span class="kw">in</span> m n r)</span></code></pre></div>
</div>
<div id="better-arbitrary-for-tree" class="slide section level1">
<h1>Better <code>Arbitrary</code> for <code>Tree</code></h1>
<div class="sourceCode" id="cb22"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> a <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (<span class="dt">Tree</span> a) <span class="kw">where</span></span>
<span id="cb22-2"><a href="#cb22-2" tabindex="-1"></a>    arbitrary <span class="ot">=</span> sized arbTree</span>
<span id="cb22-3"><a href="#cb22-3" tabindex="-1"></a></span>
<span id="cb22-4"><a href="#cb22-4" tabindex="-1"></a><span class="co">-- arbTree n generates a tree of size &lt; n</span></span>
<span id="cb22-5"><a href="#cb22-5" tabindex="-1"></a>arbTree <span class="dv">0</span> <span class="ot">=</span> <span class="dt">Leaf</span> <span class="op">&lt;$&gt;</span> arbitrary</span>
<span id="cb22-6"><a href="#cb22-6" tabindex="-1"></a>arbTree n <span class="ot">=</span> frequency</span>
<span id="cb22-7"><a href="#cb22-7" tabindex="-1"></a>        [(<span class="dv">1</span>, <span class="dt">Leaf</span> <span class="op">&lt;$&gt;</span> arbitrary)</span>
<span id="cb22-8"><a href="#cb22-8" tabindex="-1"></a>        ,(<span class="dv">4</span>, <span class="dt">Branch</span> <span class="op">&lt;$&gt;</span> arbTree (<span class="fu">div</span> n <span class="dv">2</span>) <span class="op">&lt;*&gt;</span> arbTree (<span class="fu">div</span> n <span class="dv">2</span>)</span>
<span id="cb22-9"><a href="#cb22-9" tabindex="-1"></a>        <span class="co">--   Branch &lt;$&gt; g &lt;*&gt; g where g = arbTree (div n 2)</span></span>
<span id="cb22-10"><a href="#cb22-10" tabindex="-1"></a>        ]</span></code></pre></div>
<p>NB the shorter notation in the comment is equivalent</p>
<p><code>g</code> is not a tree, but a computation producing trees.</p>
</div>
<div id="a-monad-of-generators" class="slide section level1">
<h1>A monad of generators</h1>
<div class="sourceCode" id="cb23"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a><span class="co">-- Resembles the state monad, but the state gets split in two</span></span>
<span id="cb23-2"><a href="#cb23-2" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Gen</span> <span class="kw">where</span></span>
<span id="cb23-3"><a href="#cb23-3" tabindex="-1"></a>  <span class="fu">return</span> a <span class="ot">=</span> <span class="dt">Gen</span> <span class="op">$</span> \n r <span class="ot">-&gt;</span> a</span>
<span id="cb23-4"><a href="#cb23-4" tabindex="-1"></a>  <span class="dt">Gen</span> m <span class="op">&gt;&gt;=</span> k <span class="ot">=</span> <span class="dt">Gen</span> <span class="op">$</span> \n r0 <span class="ot">-&gt;</span></span>
<span id="cb23-5"><a href="#cb23-5" tabindex="-1"></a>    <span class="kw">let</span> (r1,r2) <span class="ot">=</span> split r0</span>
<span id="cb23-6"><a href="#cb23-6" tabindex="-1"></a>        <span class="dt">Gen</span> m&#39;  <span class="ot">=</span> k (m n r1)</span>
<span id="cb23-7"><a href="#cb23-7" tabindex="-1"></a>     <span class="kw">in</span> m&#39; n r2</span>
<span id="cb23-8"><a href="#cb23-8" tabindex="-1"></a></span>
<span id="cb23-9"><a href="#cb23-9" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Gen</span> <span class="kw">where</span></span>
<span id="cb23-10"><a href="#cb23-10" tabindex="-1"></a>  <span class="fu">fmap</span> f m <span class="ot">=</span> m <span class="op">&gt;&gt;=</span> <span class="fu">return</span> <span class="op">.</span> f</span>
<span id="cb23-11"><a href="#cb23-11" tabindex="-1"></a></span>
<span id="cb23-12"><a href="#cb23-12" tabindex="-1"></a><span class="ot">chooseInt ::</span> (<span class="dt">Int</span>,<span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Gen</span> <span class="dt">Int</span></span>
<span id="cb23-13"><a href="#cb23-13" tabindex="-1"></a>chooseInt bounds <span class="ot">=</span> (<span class="fu">fst</span> <span class="op">.</span> randomR bounds) <span class="op">&lt;$&gt;</span> rand</span>
<span id="cb23-14"><a href="#cb23-14" tabindex="-1"></a></span>
<span id="cb23-15"><a href="#cb23-15" tabindex="-1"></a><span class="ot">rand ::</span> <span class="dt">Gen</span> <span class="dt">StdGen</span>  <span class="co">-- like `get` in the state monad</span></span>
<span id="cb23-16"><a href="#cb23-16" tabindex="-1"></a>rand <span class="ot">=</span> <span class="dt">Gen</span> (\n r <span class="ot">-&gt;</span> r)</span>
<span id="cb23-17"><a href="#cb23-17" tabindex="-1"></a></span>
<span id="cb23-18"><a href="#cb23-18" tabindex="-1"></a><span class="ot">choose ::</span>  <span class="dt">Random</span> a <span class="ot">=&gt;</span> (a, a) <span class="ot">-&gt;</span> <span class="dt">Gen</span> a</span>
<span id="cb23-19"><a href="#cb23-19" tabindex="-1"></a>choose bounds <span class="ot">=</span> (<span class="fu">fst</span> <span class="op">.</span> randomR bounds) <span class="op">&lt;$&gt;</span> rand</span></code></pre></div>
</div>
<div id="arbitrary" class="slide section level1">
<h1>Arbitrary</h1>
<div class="sourceCode" id="cb24"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Arbitrary</span> a <span class="kw">where</span></span>
<span id="cb24-2"><a href="#cb24-2" tabindex="-1"></a><span class="ot">  arbitrary ::</span> <span class="dt">Gen</span> a</span>
<span id="cb24-3"><a href="#cb24-3" tabindex="-1"></a></span>
<span id="cb24-4"><a href="#cb24-4" tabindex="-1"></a><span class="co">-- randomly choose one of the elements</span></span>
<span id="cb24-5"><a href="#cb24-5" tabindex="-1"></a><span class="ot">elements ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Gen</span> a</span>
<span id="cb24-6"><a href="#cb24-6" tabindex="-1"></a>elements xs <span class="ot">=</span> (xs <span class="op">!!</span>) <span class="op">&lt;$&gt;</span> choose (<span class="dv">0</span>, <span class="fu">length</span> xs <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb24-7"><a href="#cb24-7" tabindex="-1"></a></span>
<span id="cb24-8"><a href="#cb24-8" tabindex="-1"></a><span class="ot">vector ::</span> <span class="dt">Arbitrary</span> a <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> [a]</span>
<span id="cb24-9"><a href="#cb24-9" tabindex="-1"></a>vector n <span class="ot">=</span> <span class="fu">sequence</span> [ arbitrary <span class="op">|</span> i <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="op">..</span>n] ]</span>
<span id="cb24-10"><a href="#cb24-10" tabindex="-1"></a><span class="co">-- sequence :: Monad m =&gt; [m a] -&gt; m [a]</span></span>
<span id="cb24-11"><a href="#cb24-11" tabindex="-1"></a></span>
<span id="cb24-12"><a href="#cb24-12" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> () <span class="kw">where</span></span>
<span id="cb24-13"><a href="#cb24-13" tabindex="-1"></a>  arbitrary <span class="ot">=</span> <span class="fu">return</span> ()</span>
<span id="cb24-14"><a href="#cb24-14" tabindex="-1"></a></span>
<span id="cb24-15"><a href="#cb24-15" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Bool</span> <span class="kw">where</span></span>
<span id="cb24-16"><a href="#cb24-16" tabindex="-1"></a>  arbitrary <span class="ot">=</span> elements [<span class="dt">True</span>, <span class="dt">False</span>]</span>
<span id="cb24-17"><a href="#cb24-17" tabindex="-1"></a></span>
<span id="cb24-18"><a href="#cb24-18" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> a <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> [a] <span class="kw">where</span></span>
<span id="cb24-19"><a href="#cb24-19" tabindex="-1"></a>  arbitrary <span class="ot">=</span> sized (\n <span class="ot">-&gt;</span> choose (<span class="dv">0</span>,n) <span class="op">&gt;&gt;=</span> vector)</span>
<span id="cb24-20"><a href="#cb24-20" tabindex="-1"></a></span>
<span id="cb24-21"><a href="#cb24-21" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Int</span> <span class="kw">where</span></span>
<span id="cb24-22"><a href="#cb24-22" tabindex="-1"></a>  arbitrary <span class="ot">=</span> sized <span class="op">$</span> \n <span class="ot">-&gt;</span> choose (<span class="op">-</span>n,n)</span></code></pre></div>
</div>
<div id="result-of-a-test" class="slide section level1">
<h1>Result of a test</h1>
<p>A test can have one of three outcomes:</p>
<ul>
<li><code>Just True</code> - success</li>
<li><code>Just False</code> - failure (plus counterexample)</li>
<li><code>Nothing</code> - inconclusive, data not fitting for the
test</li>
</ul>
<div class="sourceCode" id="cb25"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Result</span> <span class="ot">=</span> <span class="dt">Result</span> {<span class="ot"> ok ::</span> <span class="dt">Maybe</span> <span class="dt">Bool</span>,<span class="ot"> arguments ::</span> [<span class="dt">String</span>] }</span>
<span id="cb25-2"><a href="#cb25-2" tabindex="-1"></a></span>
<span id="cb25-3"><a href="#cb25-3" tabindex="-1"></a><span class="ot">nothing ::</span> <span class="dt">Result</span></span>
<span id="cb25-4"><a href="#cb25-4" tabindex="-1"></a>nothing <span class="ot">=</span> <span class="dt">Result</span>{ ok <span class="ot">=</span> <span class="dt">Nothing</span>,  arguments <span class="ot">=</span> [] }</span>
<span id="cb25-5"><a href="#cb25-5" tabindex="-1"></a></span>
<span id="cb25-6"><a href="#cb25-6" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Property</span></span>
<span id="cb25-7"><a href="#cb25-7" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Prop</span> (<span class="dt">Gen</span> <span class="dt">Result</span>)</span></code></pre></div>
<p><code>Property</code> is a computation in the <code>Gen</code> monad,
yielding <code>Result</code></p>
</div>
<div id="testable" class="slide section level1">
<h1>Testable</h1>
<p>To test something, we need a <code>Result</code> generator
(i.e. <code>Property</code>)</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Testable</span> a <span class="kw">where</span></span>
<span id="cb26-2"><a href="#cb26-2" tabindex="-1"></a><span class="ot">  property ::</span> a <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb26-3"><a href="#cb26-3" tabindex="-1"></a></span>
<span id="cb26-4"><a href="#cb26-4" tabindex="-1"></a><span class="ot">result ::</span> <span class="dt">Result</span> <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb26-5"><a href="#cb26-5" tabindex="-1"></a>result res <span class="ot">=</span> <span class="dt">Prop</span> (<span class="fu">return</span> res)</span>
<span id="cb26-6"><a href="#cb26-6" tabindex="-1"></a></span>
<span id="cb26-7"><a href="#cb26-7" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Testable</span> () <span class="kw">where</span></span>
<span id="cb26-8"><a href="#cb26-8" tabindex="-1"></a>  property () <span class="ot">=</span> result nothing</span>
<span id="cb26-9"><a href="#cb26-9" tabindex="-1"></a></span>
<span id="cb26-10"><a href="#cb26-10" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Testable</span> <span class="dt">Bool</span> <span class="kw">where</span></span>
<span id="cb26-11"><a href="#cb26-11" tabindex="-1"></a>  property b <span class="ot">=</span> result (nothing { ok <span class="ot">=</span> <span class="dt">Just</span> b })</span>
<span id="cb26-12"><a href="#cb26-12" tabindex="-1"></a></span>
<span id="cb26-13"><a href="#cb26-13" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Testable</span> <span class="dt">Property</span> <span class="kw">where</span></span>
<span id="cb26-14"><a href="#cb26-14" tabindex="-1"></a>  property prop <span class="ot">=</span> prop</span></code></pre></div>
<pre><code>*SimpleCheck1&gt; check True
OK, passed 100 tests
*SimpleCheck1&gt; check False
Falsifiable, after 0 tests:</code></pre>
<p>(<code>False</code> has a trivial counterexample)</p>
</div>
<div id="running-tests" class="slide section level1">
<h1>Running tests</h1>
<div class="sourceCode" id="cb28"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" tabindex="-1"></a><span class="ot">generate ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb28-2"><a href="#cb28-2" tabindex="-1"></a></span>
<span id="cb28-3"><a href="#cb28-3" tabindex="-1"></a><span class="ot">tests ::</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> <span class="dt">Result</span> <span class="ot">-&gt;</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb28-4"><a href="#cb28-4" tabindex="-1"></a>tests c gen rnd0 ntest nfail</span>
<span id="cb28-5"><a href="#cb28-5" tabindex="-1"></a>  <span class="op">|</span> ntest <span class="op">==</span> configMaxTest c <span class="ot">=</span> done <span class="st">&quot;OK, passed&quot;</span> ntest</span>
<span id="cb28-6"><a href="#cb28-6" tabindex="-1"></a>  <span class="op">|</span> nfail <span class="op">==</span> configMaxFail c <span class="ot">=</span> done <span class="st">&quot;Arguments exhausted after&quot;</span> ntest</span>
<span id="cb28-7"><a href="#cb28-7" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span>               <span class="ot">=</span></span>
<span id="cb28-8"><a href="#cb28-8" tabindex="-1"></a>         <span class="kw">case</span> ok result <span class="kw">of</span></span>
<span id="cb28-9"><a href="#cb28-9" tabindex="-1"></a>           <span class="dt">Nothing</span>    <span class="ot">-&gt;</span></span>
<span id="cb28-10"><a href="#cb28-10" tabindex="-1"></a>             tests gen rnd1 ntest (nfail<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb28-11"><a href="#cb28-11" tabindex="-1"></a>           <span class="dt">Just</span> <span class="dt">True</span>  <span class="ot">-&gt;</span></span>
<span id="cb28-12"><a href="#cb28-12" tabindex="-1"></a>             tests gen rnd1 (ntest<span class="op">+</span><span class="dv">1</span>) nfail</span>
<span id="cb28-13"><a href="#cb28-13" tabindex="-1"></a>           <span class="dt">Just</span> <span class="dt">False</span> <span class="ot">-&gt;</span></span>
<span id="cb28-14"><a href="#cb28-14" tabindex="-1"></a>             <span class="fu">putStr</span> ( <span class="st">&quot;Falsifiable, after &quot;</span></span>
<span id="cb28-15"><a href="#cb28-15" tabindex="-1"></a>                   <span class="op">++</span> <span class="fu">show</span> ntest</span>
<span id="cb28-16"><a href="#cb28-16" tabindex="-1"></a>                   <span class="op">++</span> <span class="st">&quot; tests:\n&quot;</span></span>
<span id="cb28-17"><a href="#cb28-17" tabindex="-1"></a>                   <span class="op">++</span> <span class="fu">unlines</span> (arguments result)</span>
<span id="cb28-18"><a href="#cb28-18" tabindex="-1"></a>                    )</span>
<span id="cb28-19"><a href="#cb28-19" tabindex="-1"></a>     <span class="kw">where</span></span>
<span id="cb28-20"><a href="#cb28-20" tabindex="-1"></a>      result      <span class="ot">=</span> generate (configSize c ntest) rnd2 gen</span>
<span id="cb28-21"><a href="#cb28-21" tabindex="-1"></a>      (rnd1,rnd2) <span class="ot">=</span> split rnd0</span></code></pre></div>
<p><code>configSize n</code> determines data size for test
<code>n</code> (default: <code>n/2+3</code>)</p>
</div>
<div id="forall" class="slide section level1">
<h1>forAll</h1>
<div class="sourceCode" id="cb29"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" tabindex="-1"></a><span class="co">-- | `evaluate` extracts a generator from the `Testable` instance</span></span>
<span id="cb29-2"><a href="#cb29-2" tabindex="-1"></a><span class="co">-- Property = Prop (Gen Result)</span></span>
<span id="cb29-3"><a href="#cb29-3" tabindex="-1"></a><span class="ot">evaluate ::</span> <span class="dt">Testable</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Gen</span> <span class="dt">Result</span></span>
<span id="cb29-4"><a href="#cb29-4" tabindex="-1"></a>evaluate a <span class="ot">=</span> gen <span class="kw">where</span> <span class="dt">Prop</span> gen <span class="ot">=</span> property a</span>
<span id="cb29-5"><a href="#cb29-5" tabindex="-1"></a></span>
<span id="cb29-6"><a href="#cb29-6" tabindex="-1"></a><span class="ot">forAll ::</span> (<span class="dt">Show</span> a, <span class="dt">Testable</span> b) <span class="ot">=&gt;</span> <span class="dt">Gen</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb29-7"><a href="#cb29-7" tabindex="-1"></a>forAll gen body <span class="ot">=</span> <span class="dt">Prop</span> <span class="op">$</span></span>
<span id="cb29-8"><a href="#cb29-8" tabindex="-1"></a>  <span class="kw">do</span> a   <span class="ot">&lt;-</span> gen               <span class="co">-- gen :: Gen a</span></span>
<span id="cb29-9"><a href="#cb29-9" tabindex="-1"></a>     res <span class="ot">&lt;-</span> evaluate (body a) <span class="co">-- body a :: b</span></span>
<span id="cb29-10"><a href="#cb29-10" tabindex="-1"></a>     <span class="fu">return</span> (argument a res)</span>
<span id="cb29-11"><a href="#cb29-11" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb29-12"><a href="#cb29-12" tabindex="-1"></a>  argument a res <span class="ot">=</span> res{ arguments <span class="ot">=</span> <span class="fu">show</span> a <span class="op">:</span> arguments res }</span>
<span id="cb29-13"><a href="#cb29-13" tabindex="-1"></a></span>
<span id="cb29-14"><a href="#cb29-14" tabindex="-1"></a></span>
<span id="cb29-15"><a href="#cb29-15" tabindex="-1"></a>propAddCom1,<span class="ot"> propAddCom2 ::</span> <span class="dt">Property</span></span>
<span id="cb29-16"><a href="#cb29-16" tabindex="-1"></a>propAddCom1 <span class="ot">=</span>  forAll (chooseInt (<span class="op">-</span><span class="dv">100</span>,<span class="dv">100</span>)) (\x <span class="ot">-&gt;</span> x <span class="op">+</span> <span class="dv">1</span> <span class="op">==</span> <span class="dv">1</span> <span class="op">+</span> x)</span>
<span id="cb29-17"><a href="#cb29-17" tabindex="-1"></a>propAddCom2 <span class="ot">=</span>  forAll int (\x <span class="ot">-&gt;</span> forAll int (\y <span class="ot">-&gt;</span> x <span class="op">+</span> y <span class="op">==</span> y <span class="op">+</span> x)) <span class="kw">where</span></span>
<span id="cb29-18"><a href="#cb29-18" tabindex="-1"></a>  int <span class="ot">=</span> chooseInt (<span class="op">-</span><span class="dv">100</span>,<span class="dv">100</span>)</span></code></pre></div>
<pre><code>&gt;&gt;&gt; check $ forAll (chooseInt (-100,100)) (\x -&gt; x + 0 == x)
OK, passed 100 tests
&gt;&gt;&gt; check $ forAll (arbitrary::Gen Int) (\x -&gt; x + 1 == x)
Falsifiable, after 0 tests:
1</code></pre>
</div>
<div id="functions" class="slide section level1">
<h1>Functions</h1>
<p>Given <code>forAll</code>, functions are surprisingly easy:</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Arbitrary</span> a, <span class="dt">Show</span> a, <span class="dt">Testable</span> b) <span class="ot">=&gt;</span> <span class="dt">Testable</span> (a <span class="ot">-&gt;</span> b) <span class="kw">where</span></span>
<span id="cb31-2"><a href="#cb31-2" tabindex="-1"></a>  property f <span class="ot">=</span> forAll arbitrary f</span>
<span id="cb31-3"><a href="#cb31-3" tabindex="-1"></a></span>
<span id="cb31-4"><a href="#cb31-4" tabindex="-1"></a><span class="ot">propAddCom3 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb31-5"><a href="#cb31-5" tabindex="-1"></a>propAddCom3 x y <span class="ot">=</span> x <span class="op">+</span> y <span class="op">==</span> y <span class="op">+</span> x</span>
<span id="cb31-6"><a href="#cb31-6" tabindex="-1"></a></span>
<span id="cb31-7"><a href="#cb31-7" tabindex="-1"></a><span class="co">-- instance Testable Bool</span></span>
<span id="cb31-8"><a href="#cb31-8" tabindex="-1"></a><span class="co">-- instance Testable (Int -&gt; Bool)</span></span>
<span id="cb31-9"><a href="#cb31-9" tabindex="-1"></a><span class="co">-- instance Testable (Int -&gt; (Int -&gt; Bool))</span></span></code></pre></div>
</div>
<div id="implication-conditional-tests" class="slide section level1">
<h1>Implication (conditional tests)</h1>
<p>Implication: test q, providing data satisfies p</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" tabindex="-1"></a><span class="ot">(==&gt;) ::</span> <span class="dt">Testable</span> a <span class="ot">=&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb32-2"><a href="#cb32-2" tabindex="-1"></a><span class="dt">True</span>  <span class="op">==&gt;</span> a <span class="ot">=</span> property a</span>
<span id="cb32-3"><a href="#cb32-3" tabindex="-1"></a><span class="dt">False</span> <span class="op">==&gt;</span> a <span class="ot">=</span> property () <span class="co">-- bad test data</span></span>
<span id="cb32-4"><a href="#cb32-4" tabindex="-1"></a></span>
<span id="cb32-5"><a href="#cb32-5" tabindex="-1"></a><span class="ot">propMul1 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb32-6"><a href="#cb32-6" tabindex="-1"></a>propMul1 x <span class="ot">=</span> (x<span class="op">&gt;</span><span class="dv">0</span>) <span class="op">==&gt;</span> (<span class="dv">2</span><span class="op">*</span>x <span class="op">&gt;</span> <span class="dv">0</span>)</span>
<span id="cb32-7"><a href="#cb32-7" tabindex="-1"></a></span>
<span id="cb32-8"><a href="#cb32-8" tabindex="-1"></a><span class="ot">propMul2 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb32-9"><a href="#cb32-9" tabindex="-1"></a>propMul2 x y <span class="ot">=</span> (x<span class="op">&gt;</span><span class="dv">0</span>) <span class="op">==&gt;</span> (x<span class="op">*</span>y <span class="op">&gt;</span> <span class="dv">0</span>)</span></code></pre></div>
<pre><code>&gt; check propMul1
OK, passed 100 tests

&gt; check propMul2
Falsifiable, after 0 tests:
2
-2</code></pre>
<!--
# Generating functions

We can test functions, but to test higher-order functons we need to generate random functions.


Note that

~~~~ {.haskell}
Gen a ~ (Int -> StdGen -> a)
Gen(a -> b) ≃ (Int -> StdGen -> a -> b) ≃ (a -> Int -> StdGen -> b) ≃ (a -> Gen b)
~~~~

so we can write

~~~~ {.haskell}
promote :: (a -> Gen b) -> Gen (a -> b)
promote f = Gen (\n r -> \a -> let Gen m = f a in m n r)
~~~~

We can use `promote` to construct a function generator if we can create a generator family for results depending somehow on arguments

# Coarbitrary

We can describe this with a class:

~~~~ {.haskell}
class CoArbitrary a where
  coarbitrary :: a -> Gen b -> Gen b
~~~~

`coarbitrary` produces a generator transformer from its argument

Now we can use `Coarbitrary` to define `Arbitrary` instance for functions:

~~~~ {.haskell}
instance (CoArbitrary a, Arbitrary b) => Arbitrary(a->b) where
  arbitrary = promote $ \a -> coarbitrary a arbitrary
~~~~

NB in QuickCheck v1.1 `coarbitrary` is a method of `Arbitrary`;
v2 uses a different approach to function generation

**Exercise:** write a few instances of `Arbitrary` for your types.

# CoArbitrary instances

To define CoArbitrary instances

~~~~ {.haskell}
class CoArbitrary where
  coarbitrary :: a -> Gen b -> Gen b
~~~~

we need a way to construct generator transformers. Let us define the function

~~~~ {.haskell}
variant :: Int -> Gen a -> Gen a
variant v (Gen m) = Gen (\n r -> m n (rands r !! (v+1)))
 where
  rands r0 = r1 : rands r2 where (r1, r2) = split r0
~~~~

which splits the input generator into many variants and chooses one of them
depending on the argument

~~~~ {.haskell}
instance CoArbitrary Bool where
  coarbitrary False = variant 0
  coarbitrary True  = variant 1
~~~~

# Example: coarbitrary for trees

~~~~ {.haskell}
instance Arbitrary Tree where
  arbitrary = sized tree'
    where tree' 0 = liftM Leaf arbitrary
      tree' n | n>0 =
        oneof [liftM Leaf arbitrary,
              liftM2 Branch subtree subtree]
        where subtree = tree' (n `div` 2)

  coarbitrary (Leaf n) =
    variant 0 . coarbitrary n  --
    -- coarbitrary n :: Gen T -> Gen T
    -- variant 0 :: Gen T -> Gen T

  coarbitrary (Branch t1 t2) =
    variant 1 . coarbitrary t1 . coarbitrary t2
~~~~


~~~
variant :: Int -> Gen a -> Gen a
coarbitrary :: a -> Gen b -> Gen b
~~~


# Function properties

~~~~ {.haskell}
infix 4 ===
(===)  f g x = f x == g x

instance Show(a->b) where
  show f = "<function>"

propCompAssoc f g h = (f . g) . h === f . (g . h)
  where types = [f,g,h::Int->Int]
~~~~
-->
</div>
<div id="a-problem-with-implication" class="slide section level1">
<h1>A problem with implication</h1>
<pre><code>prop_insert1 x xs = ordered (insert x xs)

*Main Test.QuickCheck&gt; quickCheck prop_insert1
*** Failed! Falsifiable (after 6 tests and 7 shrinks):
0
[0,-1]</code></pre>
<p>…obviously…</p>
<pre><code>prop_insert2 x xs = ordered xs ==&gt; ordered (insert x xs)

&gt;&gt;&gt; quickCheck prop_insert2
*** Gave up! Passed only 75 tests; 1000 discarded tests.</code></pre>
<p>Probability that a random list is ordered is small…</p>
</div>
<div id="test-case-distribution" class="slide section level1">
<h1>Test case distribution</h1>
<p>…and those which are, are usually not very useful</p>
<pre><code>-- collect :: (Show a, Testable prop) =&gt; a -&gt; prop -&gt; Property
-- Attaches a label to a test case. This is used for reporting test case distribution.

prop_insert3 x xs = collect (length xs) $  ordered xs ==&gt; ordered (insert x xs)

&gt;&gt;&gt; quickCheck prop_insert3
*** Gave up! Passed only 37 tests:
51% 0
32% 1
16% 2</code></pre>
</div>
<div id="sometimes-you-need-to-write-your-own-generator"
class="slide section level1">
<h1>Sometimes you need to write your own generator</h1>
<ul>
<li>Define a new type</li>
</ul>
<pre><code>newtype OrderedInts = OrderedInts [Int]

prop_insert4 :: Int -&gt; OrderedInts -&gt; Bool
prop_insert4  x (OrderedInts xs) = ordered (insert x xs)

&gt;&gt;&gt; sample (arbitrary:: Gen OrderedInts)
OrderedInts []
OrderedInts [0,0]
OrderedInts [-2,-1,2]
OrderedInts [-4,-2,0,0,2,4]
OrderedInts [-7,-6,-6,-5,-2,-1,5]
OrderedInts [-13,-12,-11,-10,-10,-7,1,1,1,10]
OrderedInts [-13,-10,-7,-5,-2,3,10,10,13]
OrderedInts [-19,-4,26]
OrderedInts [-63,-15,37]
OrderedInts [-122,-53,-47,-43,-21,-19,29,53]</code></pre>
<p>&lt;!– # doctest + QuickCheck</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Fib</span> <span class="kw">where</span></span>
<span id="cb38-2"><a href="#cb38-2" tabindex="-1"></a></span>
<span id="cb38-3"><a href="#cb38-3" tabindex="-1"></a><span class="co">-- $setup</span></span>
<span id="cb38-4"><a href="#cb38-4" tabindex="-1"></a><span class="co">-- &gt;&gt;&gt; import Control.Applicative</span></span>
<span id="cb38-5"><a href="#cb38-5" tabindex="-1"></a><span class="co">-- &gt;&gt;&gt; import Test.QuickCheck</span></span>
<span id="cb38-6"><a href="#cb38-6" tabindex="-1"></a><span class="co">-- &gt;&gt;&gt; newtype Small = Small Int deriving Show</span></span>
<span id="cb38-7"><a href="#cb38-7" tabindex="-1"></a><span class="co">-- &gt;&gt;&gt; instance Arbitrary Small where arbitrary = Small . (`mod` 10) &lt;$&gt; arbitrary</span></span>
<span id="cb38-8"><a href="#cb38-8" tabindex="-1"></a></span>
<span id="cb38-9"><a href="#cb38-9" tabindex="-1"></a><span class="co">-- | Compute Fibonacci numbers</span></span>
<span id="cb38-10"><a href="#cb38-10" tabindex="-1"></a><span class="co">--</span></span>
<span id="cb38-11"><a href="#cb38-11" tabindex="-1"></a><span class="co">-- The following property holds:</span></span>
<span id="cb38-12"><a href="#cb38-12" tabindex="-1"></a><span class="co">--</span></span>
<span id="cb38-13"><a href="#cb38-13" tabindex="-1"></a><span class="co">-- prop&gt; \(Small n) -&gt; fib n == fib (n + 2) - fib (n + 1)</span></span>
<span id="cb38-14"><a href="#cb38-14" tabindex="-1"></a><span class="ot">fib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb38-15"><a href="#cb38-15" tabindex="-1"></a>fib <span class="dv">0</span> <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb38-16"><a href="#cb38-16" tabindex="-1"></a>fib <span class="dv">1</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb38-17"><a href="#cb38-17" tabindex="-1"></a>fib n <span class="ot">=</span> fib (n <span class="op">-</span> <span class="dv">1</span>) <span class="op">+</span> fib (n <span class="op">-</span> <span class="dv">2</span>)</span></code></pre></div>
<pre><code>stack install QuickCheck
stack exec doctest Fib.hs
Run from outside a project, using implicit global project config
Using resolver: lts-9.21 from implicit global project&#39;s config file: /Users/ben/.stack/global/stack.yaml
Examples: 5  Tried: 5  Errors: 0  Failures: 0</code></pre>
<p>–&gt;</p>
</div>
<div id="running-all-tests-in-a-module" class="slide section level1">
<h1>Running all tests in a module</h1>
<p><code>quickCheckAll</code> tests all properties with names starting
with <code>prop_</code> (and proper type). It uses TemplateHaskell.</p>
<p>The next lecture will discuss how such functions work.</p>
<p>Usage example</p>
<div class="sourceCode" id="cb40"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" tabindex="-1"></a><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></span>
<span id="cb40-2"><a href="#cb40-2" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Test.QuickCheck</span></span>
<span id="cb40-3"><a href="#cb40-3" tabindex="-1"></a></span>
<span id="cb40-4"><a href="#cb40-4" tabindex="-1"></a><span class="ot">prop_AddCom3 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb40-5"><a href="#cb40-5" tabindex="-1"></a>prop_AddCom3 x y <span class="ot">=</span> x <span class="op">+</span> y <span class="op">==</span> y <span class="op">+</span> x</span>
<span id="cb40-6"><a href="#cb40-6" tabindex="-1"></a></span>
<span id="cb40-7"><a href="#cb40-7" tabindex="-1"></a><span class="ot">prop_Mul1 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb40-8"><a href="#cb40-8" tabindex="-1"></a>prop_Mul1 x <span class="ot">=</span> (x<span class="op">&gt;</span><span class="dv">0</span>) <span class="op">==&gt;</span> (<span class="dv">2</span><span class="op">*</span>x <span class="op">&gt;</span> <span class="dv">0</span>)</span>
<span id="cb40-9"><a href="#cb40-9" tabindex="-1"></a></span>
<span id="cb40-10"><a href="#cb40-10" tabindex="-1"></a><span class="fu">return</span> []  <span class="co">-- tells TH to typecheck definitions above and insert an empty decl list</span></span>
<span id="cb40-11"><a href="#cb40-11" tabindex="-1"></a>runTests <span class="ot">=</span> <span class="op">$</span>quickCheckAll</span>
<span id="cb40-12"><a href="#cb40-12" tabindex="-1"></a></span>
<span id="cb40-13"><a href="#cb40-13" tabindex="-1"></a>main <span class="ot">=</span> runTests</span></code></pre></div>
</div>
</body>
</html>
