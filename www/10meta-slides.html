<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Marcin Benke" />
  <meta name="date" content="2024-05-14" />
  <title>Advanced Functional Programming</title>
  <style type="text/css">
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="https://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" />
  <script src="https://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Advanced Functional Programming</h1>
  <p class="subtitle">Metaprogramming - Template Haskell, Quasiquotation</p>
  <p class="author">
Marcin Benke
  </p>
  <p class="date">May 14, 2024</p>
</div>
<div id="metaprogramming---template-haskell" class="slide section level1">
<h1>Metaprogramming - Template Haskell</h1>
<p>Code for today is on github:</p>
<ul>
<li>Code/TH/Here - multiline strings with TH (aka here docs)</li>
<li>Code/TH/Projections - building declarations in TH</li>
<li>Code/TH/QQ - quasiquotation</li>
<li>Code/TH/BnfcMeta - generating quasiquoters using BNFC</li>
</ul>
</div>
<div id="problem-multiline-strings" class="slide section level1">
<h1>Problem: multiline strings</h1>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">showClass ::</span> [<span class="dt">Method</span>] <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>showClass ms <span class="ot">=</span> <span class="st">&quot;\</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="st">\.class  public Instant\n\</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="st">\.super  java/lang/Object\n\</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="st">\\n\</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="st">\;\n\</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="st">\; standard initializer\n\</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="st">\.method public &lt;init&gt;()V\n\</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="st">\   aload_0\n\</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="st">\   invokespecial java/lang/Object/&lt;init&gt;()V\n\</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="st">\   return\n\</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="st">\.end method\n&quot;</span> <span class="op">++</span> <span class="fu">unlines</span> (<span class="fu">map</span> showMethod ms)</span></code></pre></div>
</div>
<div id="template-haskell" class="slide section level1">
<h1>Template Haskell</h1>
<p>Multiline strings in Haskell according to Haskell Wiki:</p>
<pre><code>{-# LANGUAGE QuasiQuotes #-}
module Main where
import Str

longString = [str|This is a multiline string.
It contains embedded newlines. And Unicode:

Ἐν ἀρχῇ ἦν ὁ Λόγος

It ends here: |]

main = putStrLn longString
</code></pre>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Str</span>(str) <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Language.Haskell.TH</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Language.Haskell.TH.Quote</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>str <span class="ot">=</span> <span class="dt">QuasiQuoter</span> { quoteExp <span class="ot">=</span> stringE }</span></code></pre></div>
<p>Let’s try to understand how it works…</p>
</div>
<div id="perhaps-a-more-convincing-example" class="slide section level1">
<h1>Perhaps a more convincing example</h1>
<p>Building Web aps with Yesod:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Links</span> <span class="ot">=</span> <span class="dt">Links</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>mkYesod <span class="st">&quot;Links&quot;</span> [parseRoutes|</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>/ HomeR GET</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>/page1 Page1R GET</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>/page2 Page2R GET</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>|]</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Yesod</span> <span class="dt">Links</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>getHomeR  <span class="ot">=</span> defaultLayout [whamlet|<span class="kw">&lt;a </span><span class="er">href=@{Page1R}</span><span class="kw">&gt;</span>Go to page 1!|]</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>getPage1R <span class="ot">=</span> defaultLayout [whamlet|<span class="kw">&lt;a </span><span class="er">href=@{Page2R}</span><span class="kw">&gt;</span>Go to page 2!|]</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>getPage2R <span class="ot">=</span> defaultLayout [whamlet|<span class="kw">&lt;a </span><span class="er">href=@{HomeR}</span><span class="kw">&gt;</span>Go home!|]</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> warp <span class="dv">3000</span> <span class="dt">Links</span></span></code></pre></div>
<ul>
<li><code>mkYesod/parseRoutes</code> generate code routing requests to specified handlers</li>
<li><code>whamlet</code> renders HTML templates</li>
</ul>
</div>
<div id="parsing-vs-buildingsplicing" class="slide section level1">
<h1>Parsing vs building/splicing</h1>
<p>Traditional implementation pipeline:</p>
<ul>
<li>parse program text, build an AST</li>
<li>interpret/compile the AST</li>
</ul>
<p>Alternative approach:</p>
<ul>
<li>build (parts of) the AST programmatically</li>
<li>inject (``splice’’) it into parsed AST</li>
</ul>
<p>Easy in an interpreter, more careful approach needed in a compiler:</p>
<ul>
<li>compile <code>ModuleA</code></li>
<li>execute (parts of) <code>ModuleA</code> to build AST for <code>ModuleB</code></li>
<li>compile <code>ModuleB</code></li>
</ul>
</div>
<div id="parsing-haskell-code-at-runtime" class="slide section level1">
<h1>Parsing Haskell code at runtime</h1>
<p>Quotations - <code>[q| ... |]</code> are a mechanism for generating ASTs. The quasiquoter <code>q</code> determines how the bracket content is parsed (default is <code>e</code> for Haskell expressions).</p>
<p>We can do some experiments in GHCi:</p>
<pre><code>$ ghci -XTemplateHaskell

&gt; :m +Language.Haskell.TH
&gt; [| \x -&gt; 1 |]

LamE [VarP x_0] (LitE (IntegerL 1))

&gt; :t it
it :: Exp

&gt; :i Exp
data Exp
  = VarE Name
  | ConE Name
  | LitE Lit
  ...
    -- Defined in ‘Language.Haskell.TH.Syntax’

&gt; [| \x -&gt; x + 1 |]  &gt;&gt;= putStrLn . pprint
\x_0 -&gt; x_0 GHC.Num.+ 1</code></pre>
</div>
<div id="the-q-monad" class="slide section level1">
<h1>The Q monad</h1>
<p>Code generation requires certain supporting features, e.g.:</p>
<ul>
<li>ability to generate new unique names</li>
<li>ability to retrieve information about an entity</li>
<li>custom state shared by all TH code in the same module</li>
</ul>
<p>These features are supplied by a monad called <code>Q</code> (for quotation).</p>
<pre><code>&gt; :t [| \x -&gt; 1 |]
[| \x -&gt; 1 |] :: ExpQ
&gt; :i ExpQ
type ExpQ = Q Exp   -- Defined in ‘Language.Haskell.TH.Lib.Internal’

&gt; :i Q
newtype Q a = ... -- Defined in ‘Language.Haskell.TH.Syntax’
instance Monad Q</code></pre>
</div>
<div id="q-runq" class="slide section level1">
<h1>Q, runQ</h1>
<pre><code>&gt; :t runQ
runQ :: Language.Haskell.TH.Syntax.Quasi m =&gt; Q a -&gt; m a

&gt;: i Quasi
class (MonadIO m, MonadFail m) =&gt; Quasi m where ...
instance Quasi Q
instance Quasi IO</code></pre>
<p>Basically <code>runQ</code> can be used to evaluate <code>Q</code> computations both in the <code>IO</code> context (useful for experimentation).</p>
<!--
(curious about `type role Q nominal`? - see e.g. this [question](https://stackoverflow.com/questions/49209788/simplest-examples-demonstrating-the-need-for-nominal-type-role-in-haskell)
-->
<p>For convenience, most AST constructors have ``smart’’ variants, e.g.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Quote</span> m <span class="ot">=&gt;</span> <span class="dt">Lit</span> <span class="ot">-&gt;</span> m <span class="dt">Exp</span></span></code></pre></div>
<p>so instead of <code>return (LitE (IntegerL 42))</code> we can write <code>litE (IntegerL 42)</code></p>
<p>NB in recent versions we have</p>
<pre><code>[| \x -&gt; 1 |] :: Quote m =&gt; m Exp
instance Quote Q
instance Quote IO</code></pre>
<p>so that <code>runQ</code> is used less often, but the essence remains the same.</p>
</div>
<div id="splicing-structure-trees-into-a-program-1" class="slide section level1">
<h1>Splicing structure trees into a program (1)</h1>
<pre><code>&gt; int = litE . IntegerL
&gt; $(int 42)
42

&gt; 1 + $(int 41)
42</code></pre>
<p>This allows for easy ``comptime’’, e.g.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span>(int (fib <span class="dv">20</span>))</span></code></pre></div>
<p>where <code>fib 20</code> is computed at compilation time.</p>
<p>(NB <code>int</code> and <code>fib</code> need to be in another module)</p>
</div>
<div id="splicing-structure-trees-into-a-program-2" class="slide section level1">
<h1>Splicing structure trees into a program (2)</h1>
<p>Splicing and quoting can be interleaved:</p>
<pre><code>&gt; $(let x = [| 2 + 3 |] in [| 2 + $(x) |])
7

&gt; (let x = [| 2 + 3 |] in [| 2 + $(x) |]) &gt;&gt;= putStrLn . pprint
2 GHC.Num.+ (2 GHC.Num.+ 3)</code></pre>
<p>This allows to unroll recursion at comptime:</p>
<pre><code>power 0 = [| const 1 |]
power n = [| \k -&gt; k * $(power (n-1)) k |]

-- power 5 ~ \k -&gt; k * k * k * k * k * 1

-- &gt; $(power 5) 2
-- 32
</code></pre>
</div>
<div id="splicing-structure-trees-into-a-program-3" class="slide section level1">
<h1>Splicing structure trees into a program (3)</h1>
<pre><code>&gt; [| succ 1 |]
AppE (VarE GHC.Enum.succ) (LitE (IntegerL 1))
&gt; $(return it)
2</code></pre>
<p>but copying and pasting has its limits:</p>
<pre><code>&gt; $(return (AppE (VarE GHC.Enum.succ) (LitE (IntegerL 1))))

&lt;interactive&gt;: error:
    Couldn&#39;t match expected type ‘Name’ with actual type ‘a0 -&gt; a0’
    Probable cause: ‘succ’ is applied to too few arguments
    In the first argument of ‘VarE’, namely ‘succ’
    In the first argument of ‘AppE’, namely ‘(VarE succ)’

&gt; :t VarE
VarE :: Name -&gt; Exp

&gt; $(return (AppE (VarE &quot;GHC.Enum.succ&quot;) (LitE (IntegerL 1))))
&lt;interactive&gt;: error:
    • Couldn&#39;t match expected type ‘Name’ with actual type ‘[Char]’</code></pre>
<p><code>VarE</code> needs a <code>Name</code></p>
</div>
<div id="making-a-name-from-string" class="slide section level1">
<h1>Making a Name from String</h1>
<p><code>VarE</code> needs a <code>Name</code></p>
<pre><code>&gt; :t VarE
VarE :: Name -&gt; Exp

&gt; :t mkName
mkName :: String -&gt; Name

&gt; $(return (AppE (VarE (mkName &quot;succ&quot;)) (LitE (IntegerL 1))))
2

-- or $(appE (varE (mkName &quot;succ&quot;)) (litE (IntegerL 1)))</code></pre>
</div>
<div id="names-patterns-declarations" class="slide section level1">
<h1>Names, patterns, declarations</h1>
<p>So far, we have been building expressions, but we can build patterns, declarations, etc.:</p>
<pre><code>&gt; [d| p1 (a,b) = a |]
[FunD p1_0 [Clause [TupP [VarP a_1,VarP b_2]] (NormalB (VarE a_1)) []]]</code></pre>
<p><code>FunD</code> etc - see <a href="https://hackage.haskell.org/package/template-haskell-2.16.0.0/docs/Language-Haskell-TH.html#g:18">documentation</a>.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Clause</span> <span class="ot">=</span> <span class="dt">Clause</span> [<span class="dt">Pat</span>] <span class="dt">Body</span> [<span class="dt">Dec</span>]  <span class="co">-- f pats = b where decs</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Dec</span>                               <span class="co">-- declaration</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">FunD</span> <span class="dt">Name</span> [<span class="dt">Clause</span>]</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span></code></pre></div>
<p>Let us now try to build such a definition ourselves.</p>
</div>
<div id="stage-restriction" class="slide section level1">
<h1>Stage restriction</h1>
<p>Note that we need to use two modules,<br /> since definitions to be run during compilation have to be imported from a different module<br /> — the code to be run needs to be compiled first.</p>
<p>Otherwise you may see an error like</p>
<pre><code>GHC stage restriction:
      ‘build_p1’ is used in a top-level splice, quasi-quote, or annotation,
      and must be imported, not defined locally</code></pre>
</div>
<div id="build1" class="slide section level1">
<h1>Build1</h1>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Build1</span> <span class="kw">where</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Language.Haskell.TH</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- p1 (a,b) = a</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="ot">build_p1 ::</span> <span class="dt">Quote</span> m <span class="ot">=&gt;</span> m [<span class="dt">Dec</span>]</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>build_p1 <span class="ot">=</span> <span class="fu">return</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    [ <span class="dt">FunD</span> p1</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>             [ <span class="dt">Clause</span> [<span class="dt">TupP</span> [<span class="dt">VarP</span> a,<span class="dt">VarP</span> b]] (<span class="dt">NormalB</span> (<span class="dt">VarE</span> a)) []</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>             ]</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>    ] <span class="kw">where</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>       p1 <span class="ot">=</span> mkName <span class="st">&quot;p1&quot;</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>       a <span class="ot">=</span> mkName <span class="st">&quot;a&quot;</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>       b <span class="ot">=</span> mkName <span class="st">&quot;b&quot;</span></span></code></pre></div>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Language.Haskell.TH</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Build1</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="op">$</span>(build_p1)</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> p1 (<span class="dv">1</span>,<span class="dv">2</span>)</span></code></pre></div>
<!-- [REPLit](https://replit.com/@mbenke/THProjections1) -->
</div>
<div id="printing-the-declarations-we-built" class="slide section level1">
<h1>Printing the declarations we built</h1>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Build1</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Language.Haskell.TH</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="op">$</span>(build_p1)</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="ot">pprLn ::</span> <span class="dt">Ppr</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>pprLn <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="op">.</span> pprint</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- pprint :: Ppr a =&gt; a -&gt; String</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>  decs <span class="ot">&lt;-</span> build_p1</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>  pprLn decs</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> p1(<span class="dv">1</span>,<span class="dv">2</span>)</span></code></pre></div>
<pre><code>p1 (a, b) = a
1</code></pre>
<!--
Reminder about `runQ`:
``` {.haskell }
class Monad m => Quasi m where ...
instance Quasi Q where ...
instance Quasi IO where ...
runQ :: Quasi m => Q a -> m a
```
-->
<p>Reminder about the <code>Quote</code> class:</p>
<pre><code>class Monad m =&gt; Quote m where
  newName :: String -&gt; m Name

instance Quote Q -- Defined in ‘Language.Haskell.TH.Syntax’
instance Quote IO -- Defined in ‘Language.Haskell.TH.Syntax’</code></pre>
</div>
<div id="fresh-names" class="slide section level1">
<h1>Fresh names</h1>
<p>Building and transforming structure trees for a language with bindings is complicated because of possible name conflicts.</p>
<p>Luckily, TH provides the function <a href="https://hackage.haskell.org/packages/archive/template-haskell/2.14.0.0/doc/html/Language-Haskell-TH.html#v:newName">newName</a>:</p>
<pre><code>newName :: String -&gt; Q Name

ghci&gt; runQ (mapM newName $ replicate 5 &quot;x&quot;)
[x_0,x_1,x_2,x_3,x_4]</code></pre>
<p>(which, by the way, explains one of the reasons why <a href="https://hackage.haskell.org/packages/archive/template-haskell/2.14.0.0/doc/html/Language-Haskell-TH.html#t:Q">Q</a> needs to be a monad).</p>
<p>Using <code>newName</code> we can safeguard our code against name clashes.</p>
<p>Note, however, that <code>p1</code> is global and must use <code>mkName</code>, while <code>a</code> and <code>b</code> are locals, so we shall generate them using <code>newName</code>.</p>
<p>(in newer versions <code>newName</code> is a method of the <code>Quote</code> class, but its essence remains the same)</p>
<pre><code>newName &quot;&quot;
_1</code></pre>
</div>
<div id="build2" class="slide section level1">
<h1>Build2</h1>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Build2</span> <span class="kw">where</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Language.Haskell.TH</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="ot">build_p1 ::</span> <span class="dt">Quote</span> m <span class="ot">=&gt;</span> m [<span class="dt">Dec</span>]</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>build_p1 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> p1 <span class="ot">=</span> mkName <span class="st">&quot;p1&quot;</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>  a <span class="ot">&lt;-</span> newName <span class="st">&quot;a&quot;</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>  b <span class="ot">&lt;-</span> newName <span class="st">&quot;a&quot;</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>    [ <span class="dt">FunD</span> p1</span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>             [ <span class="dt">Clause</span> [<span class="dt">TupP</span> [<span class="dt">VarP</span> a, <span class="dt">VarP</span> b]] (<span class="dt">NormalB</span> (<span class="dt">VarE</span> a)) []</span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>             ]</span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>    ]</span></code></pre></div>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Language.Haskell.TH</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Build2</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="op">$</span>(build_p1)</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>  build_p1 <span class="op">&gt;&gt;=</span> <span class="fu">putStrLn</span> <span class="op">.</span> pprint</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> p1(<span class="dv">1</span>,<span class="dv">2</span>)</span></code></pre></div>
<!-- [REPLit](https://replit.com/@mbenke/THprojections2) -->
</div>
<div id="typical-th-use" class="slide section level1">
<h1>Typical TH use</h1>
<p>Let us define all projections for large (say 8-) tuples. Writing this by hand is no fun, but TH helps avoid the boilerplate.</p>
<p>Here we start by pairs, but extending it to larger tuples is a simple exercise.</p>
<p>An auxiliary function building a simple declaration may come handy, e.g.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>simpleFun name pats rhs <span class="ot">=</span> <span class="dt">FunD</span> name [<span class="dt">Clause</span> pats (<span class="dt">NormalB</span> rhs) []]</span></code></pre></div>
<p>Given a function such that <code>build_p n</code> builds the nth projection, we can build them all using <code>mapM</code></p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>build_ps <span class="ot">=</span> <span class="fu">mapM</span> build_p [<span class="dv">1</span>,<span class="dv">2</span>]</span></code></pre></div>
<p>Then we may splice the definitions into the program</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="op">$</span>(build_ps)</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">mapM_</span> <span class="fu">print</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>  [ p2_1 (<span class="dv">1</span>,<span class="dv">2</span>)</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>  , p2_2 (<span class="dv">1</span>,<span class="dv">2</span>)</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>  ]</span></code></pre></div>
</div>
<div id="build3" class="slide section level1">
<h1>Build3</h1>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Build3</span> <span class="kw">where</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Language.Haskell.TH</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="ot">simpleFun ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> [<span class="dt">Pat</span>] <span class="ot">-&gt;</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Dec</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>simpleFun name pats rhs <span class="ot">=</span> <span class="dt">FunD</span> name [<span class="dt">Clause</span> pats (<span class="dt">NormalB</span> rhs) []]</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>build_ps <span class="ot">=</span> <span class="fu">mapM</span> build_p [<span class="dv">1</span>,<span class="dv">2</span>] <span class="kw">where</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>    fname n <span class="ot">=</span> mkName <span class="op">$</span> <span class="st">&quot;p2_&quot;</span> <span class="op">++</span> <span class="fu">show</span> n</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>    build_p n <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>        argNames <span class="ot">&lt;-</span> <span class="fu">mapM</span> newName (<span class="fu">replicate</span> <span class="dv">2</span> <span class="st">&quot;a&quot;</span>)</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> args <span class="ot">=</span> <span class="fu">map</span> <span class="dt">VarP</span> argNames</span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>        <span class="fu">return</span> <span class="op">$</span> simpleFun (fname n) [<span class="dt">TupP</span> args] (<span class="dt">VarE</span> (argNames <span class="op">!!</span> (n<span class="op">-</span><span class="dv">1</span>)))</span></code></pre></div>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Build3</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>build_ps <span class="co">-- one may omit $(...) for declarations</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">mapM_</span> <span class="fu">print</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>    [ p2_1 (<span class="dv">1</span>,<span class="dv">2</span>)</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>    , p2_2 (<span class="dv">1</span>,<span class="dv">2</span>)</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>    ]</span></code></pre></div>
<p><a href="https://replit.com/@mbenke/THProjections3">REPLit</a></p>
</div>
<div id="quote-eval-quasiquote" class="slide section level1">
<h1>Quote, eval, quasiquote</h1>
<p>In Lisp we have quote: <code>'</code> (<code>code -&gt; data</code>) and eval (data -&gt; code):</p>
<pre><code>(+ 1 1)         =&gt; 2
&#39;(+ 1 1)        =&gt; (list &#39;+ 1 1)
(eval &#39;(+ 1 1)) =&gt; 2
(1 2 3)         ERROR
&#39;(1 2 3)        =&gt; (list 1 2 3)
&#39;(1 (+ 1 1) 3)  =&gt; (list 1 &#39;(+ 1 1) 3)</code></pre>
<p>and a slightly more involved quasiquote/unquote pair: <code>`/,</code> (backtick/comma)</p>
<pre><code>`(1 ,(+ 1 1) 3) =&gt; (list 1 2 3)</code></pre>
<p>enabling us to evaluate some fragments inside quoted code.</p>
<p>In Lisp there are only S-expressions, Haskell syntax is more complex:</p>
<ul>
<li>expressions</li>
<li>patterns</li>
<li>types</li>
<li>declarations</li>
</ul>
</div>
<div id="quasiquoting" class="slide section level1">
<h1>Quasiquoting</h1>
<p>We have seen the standard quasiquoters e, t, d, p (e.g. <code>[e| \x -&gt; x +1|]</code> ). We can also define our own:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>longString <span class="ot">=</span> [str|This is a multiline string.</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>It contains embedded newlines. And Unicode:</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>Ἐν ἀρχῇ ἦν ὁ Λόγος</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>It ends here: |]</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">putStrLn</span> longString</span></code></pre></div>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Str</span>(str) <span class="kw">where</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Language.Haskell.TH</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Language.Haskell.TH.Quote</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>str <span class="ot">=</span> <span class="dt">QuasiQuoter</span> { quoteExp <span class="ot">=</span> stringE }</span></code></pre></div>
<ul>
<li><code>stringE</code> builds a string literal expression (<code>stringE :: String -&gt; Q Exp</code>)</li>
<li><code>str</code> quasiquoter, when used in expression context, splices this literal</li>
</ul>
</div>
<div id="the-quasiquoter-type" class="slide section level1">
<h1>The QuasiQuoter type</h1>
<pre><code>&gt; :i QuasiQuoter
data QuasiQuoter
  = QuasiQuoter {quoteExp :: String -&gt; Q Exp,
                 quotePat :: String -&gt; Q Pat,
                 quoteType :: String -&gt; Q Type,
                 quoteDec :: String -&gt; Q [Dec]}
    -- Defined in ‘Language.Haskell.TH.Quote’</code></pre>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>str <span class="ot">=</span> <span class="dt">QuasiQuoter</span> { quoteExp <span class="ot">=</span> stringE }</span></code></pre></div>
<p>We intend to use <code>str</code> only in expression contexts, so we leave the other parts undefined.</p>
</div>
<div id="parsing-expressions" class="slide section level1">
<h1>Parsing Expressions</h1>
<p>Let’s start with a simple data type and parser for arithmetic expressions</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveDataTypeable #-}</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span> <span class="ot">=</span> <span class="dt">EInt</span> <span class="dt">Int</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">EVar</span> <span class="dt">Var</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">EAdd</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">ESub</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">EMul</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">EDiv</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span>(<span class="dt">Show</span>,<span class="dt">Typeable</span>,<span class="dt">Data</span>)</span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- deriving Data needed to use generic function</span></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a><span class="co">-- liftData :: Data a =&gt; a -&gt; ExpQ</span></span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a><span class="ot">pExpr ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a><span class="co">-- ...</span></span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-16"><a href="#cb40-16" aria-hidden="true" tabindex="-1"></a>test1 <span class="ot">=</span> parse pExpr <span class="st">&quot;test1&quot;</span> <span class="st">&quot;1 - 2 - 3 * 4 &quot;</span></span>
<span id="cb40-17"><a href="#cb40-17" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> test1</span></code></pre></div>
<pre><code>Right (ESub (ESub (EInt 1) (EInt 2)) (EMul (EInt 3) (EInt 4)))</code></pre>
</div>
<div id="building-test-cases" class="slide section level1">
<h1>Building test cases</h1>
<p>Now let’s say we need some expresion trees in our program. For this kind of expressions we could (almost) get by with <code>class Num</code> hack:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Expr</span> <span class="kw">where</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fromInteger</span> <span class="ot">=</span> <span class="dt">EInt</span> <span class="op">.</span> <span class="fu">fromInteger</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>  (<span class="op">+</span>) <span class="ot">=</span> <span class="dt">EAdd</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>  (<span class="op">*</span>) <span class="ot">=</span> <span class="dt">EMul</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>  (<span class="op">-</span>) <span class="ot">=</span> <span class="dt">ESub</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a><span class="ot">testExpr ::</span> <span class="dt">Expr</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>testExpr <span class="ot">=</span> (<span class="dv">2</span> <span class="op">+</span> <span class="dv">2</span>) <span class="op">*</span> <span class="dv">3</span></span></code></pre></div>
<p>…but it is neither extensible nor, in fact, nice.</p>
</div>
<div id="building-test-cases-via-parsing" class="slide section level1">
<h1>Building test cases via parsing</h1>
<p>Of course as soon as we have a parser ready we could use it to build expressions</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>testExpr <span class="ot">=</span> parse pExpr <span class="st">&quot;testExpr&quot;</span> <span class="st">&quot;1+2*3&quot;</span></span></code></pre></div>
<p>…but then potential errors in the expression texts remain undetected until runtime, and also this is not flexible enough: what if we wanted a simplifier for expressions, along the lines of</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="ot">simpl ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>simpl (<span class="dt">EAdd</span> (<span class="dt">EInt</span> <span class="dv">0</span>) x) <span class="ot">=</span> x</span></code></pre></div>
<p>wouldn’t it be nice to be able to write this instead:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>simpl (<span class="dv">0</span> <span class="op">+</span> x) <span class="ot">=</span> x</span></code></pre></div>
</div>
<div id="building-test-cases-with-th" class="slide section level1">
<h1>Building test cases with TH</h1>
<p>Using TH seemingly makes matters only worse:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="ot">testExpr ::</span> <span class="dt">Expr</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>testExpr <span class="ot">=</span> <span class="op">$</span>(<span class="fu">return</span> <span class="op">$</span> mkAdd (mkInt <span class="dv">0</span>) (mkInt <span class="dv">2</span>))</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a><span class="ot">simpl ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>simpl <span class="op">$</span>(<span class="fu">return</span> <span class="op">$</span> mkAddP (mkIntP <span class="dv">0</span>) (<span class="dt">VarP</span> (mkName <span class="st">&quot;x&quot;</span>))) <span class="ot">=</span> x</span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a><span class="ot">mkIntP ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Pat</span></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>mkIntP i <span class="ot">=</span> <span class="dt">ConP</span> (mkName <span class="st">&quot;EInt&quot;</span>) [<span class="dt">LitP</span> <span class="op">$</span> <span class="dt">IntegerL</span> i]</span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a><span class="ot">mkBinP ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Pat</span> <span class="ot">-&gt;</span> <span class="dt">Pat</span> <span class="ot">-&gt;</span> <span class="dt">Pat</span></span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>mkBinP s p1 p2 <span class="ot">=</span> <span class="dt">ConP</span> (mkName s) [p1, p2]</span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a><span class="ot">mkAddP ::</span> <span class="dt">Pat</span> <span class="ot">-&gt;</span> <span class="dt">Pat</span> <span class="ot">-&gt;</span> <span class="dt">Pat</span></span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a>mkAddP <span class="ot">=</span> mkBinP <span class="st">&quot;EAdd&quot;</span></span></code></pre></div>
<p>…but there’s a better way</p>
</div>
<div id="why-its-good-to-be-quasiquoted" class="slide section level1">
<h1>Why it’s Good to be Quasiquoted</h1>
<p>what if we could instead write</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="ot">simpl ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>simpl (<span class="dv">0</span> <span class="op">+</span> x) <span class="ot">=</span> x</span></code></pre></div>
<p>turns out with quasiquotation we can do just that (albeit with a slightly different syntax), so to whet your appetite:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="ot">simpl ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>simpl [expr|0 + $x|] <span class="ot">=</span> x</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> simpl [expr|0+2|]</span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- ...</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a><span class="ot">expr  ::</span> <span class="dt">QuasiQuoter</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>expr  <span class="ot">=</span>  <span class="dt">QuasiQuoter</span></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>  { quoteExp <span class="ot">=</span> quoteExprExp</span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>  , quotePat <span class="ot">=</span> quoteExprPat</span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>Let us start with the (perhaps simplest) quasiquoter for expressions:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="ot">quoteExprExp ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Exp</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>quoteExprExp s <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>  pos <span class="ot">&lt;-</span> getPosition</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">exp</span> <span class="ot">&lt;-</span> parseExp pos s</span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>  exprToExpQ <span class="fu">exp</span></span></code></pre></div>
</div>
<div id="quasiquoting-expressions" class="slide section level1">
<h1>Quasiquoting Expressions</h1>
<p>There are three steps:</p>
<ul>
<li>record the current position in Haskell file (for parse error reporting);</li>
<li>parse the expression into our abstract syntax;</li>
<li>convert our abstract syntax to its Template Haskell representation.</li>
</ul>
<p>The first step is accomplished using <a href="http://hackage.haskell.org/packages/archive/template-haskell/2.14.0.0/doc/html/Language-Haskell-TH.html#v:location">Language.Haskell.TH.location</a> and converting it to something usable by Parsec:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>getPosition <span class="ot">=</span> <span class="fu">fmap</span> transPos location <span class="kw">where</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>  transPos loc <span class="ot">=</span> (loc_filename loc,</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>                  <span class="fu">fst</span> (loc_start loc),</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>                  <span class="fu">snd</span> (loc_start loc))</span></code></pre></div>
<p>Parsing is done with our expression parser, but building the Haskell AST is a bit of work.</p>
</div>
<div id="building-ast" class="slide section level1">
<h1>Building AST</h1>
<p>Next we need to build Haskell AST from expression tree built by our parser:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="ot">exprToExpQ ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Exp</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>exprToExpQ (<span class="dt">EInt</span> n) <span class="ot">=</span> <span class="fu">return</span> <span class="op">$</span> <span class="dt">ConE</span> (mkName <span class="st">&quot;EInt&quot;</span>) <span class="op">$$</span> (intLitE n)</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>exprToExpQ (<span class="dt">EAdd</span> e1 e2) <span class="ot">=</span> convertBinE <span class="st">&quot;EAdd&quot;</span> e1 e2</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>exprToExpQ (<span class="dt">ESub</span> e1 e2) <span class="ot">=</span> convertBinE <span class="st">&quot;ESub&quot;</span> e1 e2</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>exprToExpQ (<span class="dt">EMul</span> e1 e2) <span class="ot">=</span> convertBinE <span class="st">&quot;EMul&quot;</span> e1 e2</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>exprToExpQ (<span class="dt">EDiv</span> e1 e2) <span class="ot">=</span> convertBinE <span class="st">&quot;EDiv&quot;</span> e1 e2</span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>convertBinE s e1 e2 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>  e1&#39; <span class="ot">&lt;-</span> exprToExpQ e1</span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a>  e2&#39; <span class="ot">&lt;-</span> exprToExpQ e2</span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> <span class="dt">ConE</span> (mkName s) <span class="op">$$</span> e1&#39; <span class="op">$$</span> e2&#39;</span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a>(<span class="op">$$</span>) <span class="ot">=</span> <span class="dt">AppE</span>  <span class="co">-- TH AST node for application</span></span></code></pre></div>
<p>(alternatively we might make our parser return Haskell AST)</p>
</div>
<div id="scrap-your-boilerplate" class="slide section level1">
<h1>Scrap Your Boilerplate</h1>
<p>This seems like a lot of boilerplate, luckily we can save us some work use facilities for generic programming provided by <a href="http://hackage.haskell.org/package/base/docs/Data-Data.html">Data.Data</a> combined with the Template Haskell function <a href="http://hackage.haskell.org/package/template-haskell-2.20.0.0/docs/Language-Haskell-TH-Syntax.html#v:dataToExpQ"><code>dataToExpQ</code></a>,</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a> exprToExpQ <span class="ot">=</span>  dataToExpQ (<span class="fu">const</span> <span class="dt">Nothing</span>) <span class="fu">exp</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- dataToExpQ :: Data a</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a><span class="co">--            =&gt; (forall b. Data b =&gt; b -&gt; Maybe (Q Exp))</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a><span class="co">--            -&gt; a -&gt; Q Exp</span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- the first argument provides a way of extending the translation</span></span></code></pre></div>
<p>or a simpler <a href="https://hackage.haskell.org/package/template-haskell-2.20.0.0/docs/Language-Haskell-TH-Syntax.html#v:liftData">liftData</a></p>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="ot">liftData ::</span> <span class="dt">Data</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Exp</span></span></code></pre></div>
</div>
<div id="data.data.data" class="slide section level1">
<h1>Data.Data.Data</h1>
<p>To use <code>dataToExpQ</code> or <code>liftData</code> we need a <code>Data.Data.Data</code> instance for <code>Expr</code>:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveDataTypeable #-}</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Expr</span> <span class="kw">where</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Typeable</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Data</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span> <span class="ot">=</span> <span class="dt">EInt</span> <span class="dt">Int</span></span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>         <span class="op">|</span> <span class="dt">EAdd</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a>         <span class="op">|</span> <span class="dt">ESub</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a>         <span class="op">|</span> <span class="dt">EMul</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a>         <span class="op">|</span> <span class="dt">EDiv</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a>           <span class="kw">deriving</span>(<span class="dt">Show</span>,<span class="dt">Typeable</span>,<span class="dt">Data</span>)</span></code></pre></div>
</div>
<div id="quasiquoting-patterns" class="slide section level1">
<h1>Quasiquoting patterns</h1>
<p>So far, we are halfway through to our goal: we can use the quasiquoter on the right hand side of function definitions:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="ot">testExpr ::</span> <span class="dt">Expr</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>testExpr <span class="ot">=</span> [expr|1+2*3|]</span></code></pre></div>
<p>To be able to write things like</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>simpl [expr|0 + $x|] <span class="ot">=</span> x</span></code></pre></div>
<p>we need to write a quasiquoter for patterns.</p>
</div>
<div id="quasiquoting-constant-patterns" class="slide section level1">
<h1>Quasiquoting constant patterns</h1>
<p>Let us start with something less ambitious - a quasiquoter for constant patterns, allowing us to write</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="ot">testExpr ::</span> <span class="dt">Expr</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>testExpr <span class="ot">=</span> [expr|1+2*3|]</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a><span class="ot">f1 ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>f1 [expr| 1 + 2*3 |] <span class="ot">=</span> <span class="st">&quot;Bingo!&quot;</span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>f1 _ <span class="ot">=</span> <span class="st">&quot;Sorry, no bonus&quot;</span></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="op">$</span> f1 testExpr</span></code></pre></div>
<p>This can be done similarly to the quasiquoter for expressions:</p>
<ul>
<li>record the current position in Haskell file (for parse error reporting);</li>
<li>parse the expression into our abstract syntax;</li>
<li>convert our abstract syntax to its Template Haskell representation.</li>
</ul>
</div>
<div id="building-pattern-ast" class="slide section level1">
<h1>Building pattern AST</h1>
<p>This time we need to construct Template Haskell pattern representation:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="ot">quoteExprPat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Pat</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>quoteExprPat s <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>  pos <span class="ot">&lt;-</span> getPosition</span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">exp</span> <span class="ot">&lt;-</span> parseExpr pos s</span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>  dataToPatQ (<span class="fu">const</span> <span class="dt">Nothing</span>) <span class="fu">exp</span></span></code></pre></div>
<p>The functions <code>quoteExprExp</code> and <code>quoteExprPat</code> differ in two respects:</p>
<ul>
<li>use <code>dataToPatQ</code> instead of <code>dataToExpQ</code></li>
<li>the result type is different (obviously)</li>
</ul>
</div>
<div id="antiquotation" class="slide section level1">
<h1>Antiquotation</h1>
<p>The quasiquotation mechanism we have seen so far allows us to translate domain-specific code into Haskell and “inject” it into our program.</p>
<p>Antiquotation, as the name suggests goes in the opposite direction: embeds Haskell entities (e.g. variables) in our DSL.</p>
<p>This sounds complicated, but isn’t really. Think HTML templates:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;html&gt;</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;head&gt;</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;title&gt;</span>#{pageTitle}</span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;body&gt;&lt;h1&gt;</span>#{pageTitle}</span></code></pre></div>
<p>The meaning is hopefully obvious — the value of program variable <code>pageTitle</code> should be embedded in the indicated places. In our expression language we might want to write</p>
<pre><code>twice :: Expr -&gt; Expr
twice e = [expr| $e + $e |]

testTwice = twice [expr| 3 * 3|]</code></pre>
<p>This is nothing revolutionary.</p>
<p>Haskell however, uses variables not only in expressions, but also in patterns, and here the story becomes a little interesting.</p>
</div>
<div id="extending-quasiquoters" class="slide section level1">
<h1>Extending quasiquoters</h1>
<p>Recall the pattern quasiquoter:</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="ot">quoteExprPat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Pat</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>quoteExprPat s <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>  pos <span class="ot">&lt;-</span> getPosition</span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">exp</span> <span class="ot">&lt;-</span> parseExpr pos s</span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>  dataToPatQ (<span class="fu">const</span> <span class="dt">Nothing</span>) <span class="fu">exp</span></span></code></pre></div>
<p>The <code>(const Nothing)</code> is a placeholder for extensions to the standard <code>Data</code> to <code>Pat</code> translation:</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="ot">quoteExprPat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Pat</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>quoteExprPat s <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>  pos <span class="ot">&lt;-</span> getPosition</span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">exp</span> <span class="ot">&lt;-</span> Expr.parseExpr pos s</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>  dataToPatQ (<span class="fu">const</span> <span class="dt">Nothing</span> <span class="ot">`extQ`</span> antiExprPat) <span class="fu">exp</span></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a><span class="ot">antiExprPat ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Q</span> <span class="dt">Pat</span>)</span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>antiExprPat (<span class="dt">EMetaVar</span> v) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> varP (mkName v)</span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a>antiExprPat _ <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>What are the “extensions”?</p>
</div>
<div id="whats-a-function-extension" class="slide section level1">
<h1>What’s a function extension?</h1>
<p>You have</p>
<ul>
<li>a generic function, say</li>
</ul>
<pre><code>gen :: Data a =&gt; a -&gt; R</code></pre>
<ul>
<li>a type-specific function, say</li>
</ul>
<pre><code>spec :: T -&gt; R</code></pre>
<p>You want a generic function which behaves like spec on values of type T, and like gen on all other values.</p>
<p>The function <code>extQ</code> does just that.</p>
<pre><code>extQ :: (Typeable a, Typeable t) =&gt; (a -&gt; r) -&gt; (t -&gt; r) -&gt; a -&gt; r

gen `extQ` spec :: Data a =&gt; a -&gt; R  -- Data is a subclass of Typeable</code></pre>
<p>(NB <code>extQ</code> comes from <code>Data.Generics</code> and the <code>Q</code> in the name has nothing to do with Template Haskell <code>Q</code> monad)</p>
</div>
<div id="extending-datatopatq" class="slide section level1">
<h1>Extending <code>dataToPatQ</code></h1>
<pre><code>const Nothing :: b -&gt; Maybe (Q Pat)

extQ :: (Data a, Data t) =&gt; (a -&gt; r) -&gt; (t -&gt; r) -&gt; a -&gt; r
-- specialized to Data

antiExprPat :: Expr -&gt; Maybe (Q Pat)

const Nothing `extQ` antiExprPat :: forall b.Data b =&gt; b -&gt; Maybe (Q Pat)

dataToPatQ
  :: Data a =&gt;
     (forall b.Data b =&gt; b -&gt; Maybe (Q Pat)) -&gt; a -&gt; Q Pat
-- specialized To Expr
-- :: (forall b.Data b =&gt; b -&gt; Maybe (Q Pat)) -&gt; Expr -&gt; Q Pat

dataToPatQ (const Nothing `extQ` antiExprPat) :: Expr -&gt; Q Pat</code></pre>
</div>
<div id="metavariables" class="slide section level1">
<h1>Metavariables</h1>
<p>Let us extend our expression syntax and parser with metavariables (variables from the metalanguage):</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span> <span class="ot">=</span>  <span class="op">...</span> <span class="op">|</span> <span class="dt">EMetaVar</span> <span class="dt">String</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>           <span class="kw">deriving</span>(<span class="dt">Show</span>,<span class="dt">Typeable</span>,<span class="dt">Data</span>)</span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a><span class="ot">pExpr ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a>pExpr <span class="ot">=</span> pTerm <span class="ot">`chainl1`</span> spaced addop</span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a>pTerm <span class="ot">=</span> spaced pFactor <span class="ot">`chainl1`</span> spaced mulop</span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a>pFactor <span class="ot">=</span> pNum <span class="op">&lt;|&gt;</span> pMetaVar</span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true" tabindex="-1"></a>pMetaVar <span class="ot">=</span> char <span class="ch">&#39;$&#39;</span> <span class="op">&gt;&gt;</span> <span class="dt">EMetaVar</span> <span class="op">&lt;$&gt;</span> ident</span>
<span id="cb67-11"><a href="#cb67-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-12"><a href="#cb67-12" aria-hidden="true" tabindex="-1"></a>test1 <span class="ot">=</span> parse pExpr <span class="st">&quot;test1&quot;</span> <span class="st">&quot;1 - 2 - 3 * 4 &quot;</span></span>
<span id="cb67-13"><a href="#cb67-13" aria-hidden="true" tabindex="-1"></a>test2 <span class="ot">=</span> parse pExpr <span class="st">&quot;test2&quot;</span> <span class="st">&quot;$x - $y*$z&quot;</span></span>
<span id="cb67-14"><a href="#cb67-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-15"><a href="#cb67-15" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> test1</span>
<span id="cb67-16"><a href="#cb67-16" aria-hidden="true" tabindex="-1"></a><span class="dt">Right</span> (<span class="dt">ESub</span> (<span class="dt">ESub</span> (<span class="dt">EInt</span> <span class="dv">1</span>) (<span class="dt">EInt</span> <span class="dv">2</span>)) (<span class="dt">EMul</span> (<span class="dt">EInt</span> <span class="dv">3</span>) (<span class="dt">EInt</span> <span class="dv">4</span>)))</span>
<span id="cb67-17"><a href="#cb67-17" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> test2</span>
<span id="cb67-18"><a href="#cb67-18" aria-hidden="true" tabindex="-1"></a><span class="dt">Right</span> (<span class="dt">ESub</span> (<span class="dt">EMetaVar</span> <span class="st">&quot;x&quot;</span>) (<span class="dt">EMul</span> (<span class="dt">EMetaVar</span> <span class="st">&quot;y&quot;</span>) (<span class="dt">EMetaVar</span> <span class="st">&quot;z&quot;</span>)))</span></code></pre></div>
</div>
<div id="antiquoting-metavariables" class="slide section level1">
<h1>Antiquoting metavariables</h1>
<p>The antiquoter is defined as an extension for the <code>dataToPatQ</code>:</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="ot">antiExprPat ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Q</span> <span class="dt">Pat</span>)</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>antiExprPat (<span class="dt">EMetaVar</span> v) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> varP (mkName v)</span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>antiExprPat _ <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<ul>
<li>metavariables are translated to <code>Just</code> TH variables</li>
<li>for all the other cases we say <code>Nothing</code> - allowing <code>dataToPatQ</code> use its default rules</li>
</ul>
<p>And that’s it! Now we can write</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>eval [expr| $a + $b|] <span class="ot">=</span> eval a <span class="op">+</span> eval b</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>eval [expr| $a * $b|] <span class="ot">=</span> eval a <span class="op">*</span> eval b</span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">EInt</span> n) <span class="ot">=</span> n</span></code></pre></div>
</div>
<div id="bnfc-meta" class="slide section level1">
<h1>bnfc-meta</h1>
<p>Instead of writing a parser by hand, we can use BNFC.</p>
<p>Similarly we can use <code>bnfc-meta</code> to generate quasiquoters:</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Expr</span> <span class="kw">where</span></span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Language.LBNF.Compiletime</span></span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Language.LBNF</span>(lbnf, bnfc)</span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a>bnfc [lbnf|</span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true" tabindex="-1"></a>EAdd . Expr1 ::= Expr1 &quot;+&quot; Expr2 ;</span>
<span id="cb70-7"><a href="#cb70-7" aria-hidden="true" tabindex="-1"></a>EMul . Expr2 ::= Expr2 &quot;*&quot; Expr3 ;</span>
<span id="cb70-8"><a href="#cb70-8" aria-hidden="true" tabindex="-1"></a>ELit . Expr3 ::= Integer ;</span>
<span id="cb70-9"><a href="#cb70-9" aria-hidden="true" tabindex="-1"></a>EVar . Expr3 ::= Ident ;</span>
<span id="cb70-10"><a href="#cb70-10" aria-hidden="true" tabindex="-1"></a>coercions Expr 3;</span>
<span id="cb70-11"><a href="#cb70-11" aria-hidden="true" tabindex="-1"></a>|]</span>
<span id="cb70-12"><a href="#cb70-12" aria-hidden="true" tabindex="-1"></a><span class="co">------------------------------------------------------------------</span></span>
<span id="cb70-13"><a href="#cb70-13" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Expr</span></span>
<span id="cb70-14"><a href="#cb70-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-15"><a href="#cb70-15" aria-hidden="true" tabindex="-1"></a><span class="ot">exp1 ::</span> <span class="dt">Expr</span></span>
<span id="cb70-16"><a href="#cb70-16" aria-hidden="true" tabindex="-1"></a>exp1 <span class="ot">=</span> [expr| 2 + 2 |]</span></code></pre></div>
</div>
<div id="exercises" class="slide section level1">
<h1>Exercises</h1>
<ul>
<li>Write a function such that <code>build_ps n</code> generates all projections for n-tuples,</li>
<li>Write a function <code>tupleFromList</code> such that</li>
</ul>
<pre><code>$(tupleFromList 8) [1..8] == (1,2,3,4,5,6,7,8)</code></pre>
<ul>
<li>W rite a <code>matrix</code> quasiquoter such that</li>
</ul>
<pre><code>*MatrixSplice&gt; :{
*MatrixSplice| [matrix|
*MatrixSplice| 1 2
*MatrixSplice| 3 4
*MatrixSplice| |]
*MatrixSplice| :}
[[1,2],[3,4]]</code></pre>
<p>be careful with blank lines!</p>
<ul>
<li><p>Extend the expression simplifier with more rules.</p></li>
<li><p>Extend the expression quasiquoter to handle metavariables for numeric constants, allowing to implement simplification rules like</p></li>
</ul>
<pre><code>simpl [expr|$int:n$ + $int:m$|] = [expr| $int:m+n$ |]</code></pre>
<p>(you are welcome to invent your own syntax in place of <code>$int: ... $</code>)</p>
<ul>
<li>generate expression quasiquoters using <code>bnfc-meta</code></li>
</ul>
</div>
</body>
</html>
