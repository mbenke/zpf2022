<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Marcin Benke" />
  <title>Advanced Functional Programming</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Advanced Functional Programming</h1>
<p class="subtitle">Metaprogramming - Template Haskell,
Quasiquotation</p>
<p class="author">Marcin Benke</p>
<p class="date">Apr 29, 2025</p>
</header>
<h1 id="metaprogramming---template-haskell">Metaprogramming - Template
Haskell</h1>
<p>Code for today is on github:</p>
<ul>
<li>Code/TH/Here - multiline strings with TH (aka here docs)</li>
<li>Code/TH/Projections - building declarations in TH</li>
<li>Code/TH/QQ - quasiquotation</li>
<li>Code/TH/BnfcMeta - generating quasiquoters using BNFC</li>
</ul>
<h1 id="problem-multiline-strings">Problem: multiline strings</h1>
<div class="sourceCode" id="cb1"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">showClass ::</span> [<span class="dt">Method</span>] <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>showClass ms <span class="ot">=</span> <span class="st">&quot;\</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="st">\.class  public Instant\n\</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="st">\.super  java/lang/Object\n\</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="st">\\n\</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="st">\;\n\</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="st">\; standard initializer\n\</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="st">\.method public &lt;init&gt;()V\n\</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="st">\   aload_0\n\</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="st">\   invokespecial java/lang/Object/&lt;init&gt;()V\n\</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="st">\   return\n\</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="st">\.end method\n&quot;</span> <span class="op">++</span> <span class="fu">unlines</span> (<span class="fu">map</span> showMethod ms)</span></code></pre></div>
<h1 id="template-haskell">Template Haskell</h1>
<p>Multiline strings in Haskell according to Haskell Wiki:</p>
<pre><code>{-# LANGUAGE QuasiQuotes #-}
module Main where
import Str

longString = [str|This is a multiline string.
It contains embedded newlines. And Unicode:

Ἐν ἀρχῇ ἦν ὁ Λόγος

It ends here: |]

main = putStrLn longString
</code></pre>
<div class="sourceCode" id="cb3"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Str</span>(str) <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Language.Haskell.TH</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Language.Haskell.TH.Quote</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>str <span class="ot">=</span> <span class="dt">QuasiQuoter</span> { quoteExp <span class="ot">=</span> stringE }</span></code></pre></div>
<p>Let’s try to understand how it works…</p>
<h1 id="perhaps-a-more-convincing-example">Perhaps a more convincing
example</h1>
<p>Building Web aps with Yesod:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Links</span> <span class="ot">=</span> <span class="dt">Links</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>mkYesod <span class="st">&quot;Links&quot;</span> [parseRoutes|</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>/      HomeR  GET</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>/page1 Page1R GET</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>/page2 Page2R GET</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>|]</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Yesod</span> <span class="dt">Links</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>getHomeR  <span class="ot">=</span> defaultLayout [whamlet|<span class="kw">&lt;a </span><span class="er">href=@{Page1R}</span><span class="kw">&gt;</span>Go to page 1!|]</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>getPage1R <span class="ot">=</span> defaultLayout [whamlet|<span class="kw">&lt;a </span><span class="er">href=@{Page2R}</span><span class="kw">&gt;</span>Go to page 2!|]</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>getPage2R <span class="ot">=</span> defaultLayout [whamlet|<span class="kw">&lt;a </span><span class="er">href=@{HomeR}</span><span class="kw">&gt;</span>Go home!|]</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> warp <span class="dv">3000</span> <span class="dt">Links</span></span></code></pre></div>
<ul>
<li><code>mkYesod/parseRoutes</code> generate code routing requests to
specified handlers</li>
<li><code>whamlet</code> renders HTML templates</li>
</ul>
<h1 id="parsing-vs-buildingsplicing">Parsing vs building/splicing</h1>
<p>Traditional implementation pipeline:</p>
<ul>
<li>parse program text, build an AST</li>
<li>interpret/compile the AST</li>
</ul>
<p>Alternative approach:</p>
<ul>
<li>build (parts of) the AST programmatically</li>
<li>inject (``splice’’) it into parsed AST</li>
</ul>
<p>Easy in an interpreter, more careful approach needed in a
compiler:</p>
<ul>
<li>compile <code>ModuleA</code></li>
<li>execute (parts of) <code>ModuleA</code> to build AST for
<code>ModuleB</code></li>
<li>compile <code>ModuleB</code></li>
</ul>
<h1 id="parsing-haskell-code-at-runtime">Parsing Haskell code at
runtime</h1>
<p>Quotations - <code>[q| ... |]</code> are a mechanism for generating
ASTs. The quasiquoter <code>q</code> determines how the bracket content
is parsed (default is <code>e</code> for Haskell expressions).</p>
<p>We can do some experiments in GHCi:</p>
<pre><code>$ ghci -XTemplateHaskell

&gt; :m +Language.Haskell.TH
&gt; [| \x -&gt; 1 |]

LamE [VarP x_0] (LitE (IntegerL 1))

&gt; :t it
it :: Exp

&gt; :i Exp
data Exp
  = VarE Name
  | ConE Name
  | LitE Lit
  ...
    -- Defined in ‘Language.Haskell.TH.Syntax’

&gt; [| \x -&gt; x + 1 |]  &gt;&gt;= putStrLn . pprint
\x_0 -&gt; x_0 GHC.Num.+ 1</code></pre>
<h1 id="the-q-monad">The Q monad</h1>
<p>Code generation requires certain supporting features, e.g.:</p>
<ul>
<li>ability to generate new unique names</li>
<li>ability to retrieve information about an entity</li>
<li>custom state shared by all TH code in the same module</li>
</ul>
<p>These features are supplied by a monad called <code>Q</code> (for
quotation).</p>
<pre><code>&gt; :t [| \x -&gt; 1 |]
[| \x -&gt; 1 |] :: ExpQ
&gt; :i ExpQ
type ExpQ = Q Exp   -- Defined in ‘Language.Haskell.TH.Lib.Internal’

&gt; :i Q
newtype Q a = ... -- Defined in ‘Language.Haskell.TH.Syntax’
instance Monad Q</code></pre>
<h1 id="q-runq">Q, runQ</h1>
<pre><code>&gt; :t runQ
runQ :: Language.Haskell.TH.Syntax.Quasi m =&gt; Q a -&gt; m a

&gt;: i Quasi
class (MonadIO m, MonadFail m) =&gt; Quasi m where ...
instance Quasi Q
instance Quasi IO</code></pre>
<p>Basically <code>runQ</code> can be used to evaluate <code>Q</code>
computations both in the <code>IO</code> context (useful for
experimentation).</p>
<!--
(curious about `type role Q nominal`? - see e.g. this [question](https://stackoverflow.com/questions/49209788/simplest-examples-demonstrating-the-need-for-nominal-type-role-in-haskell)
-->
<p>For convenience, most AST constructors have ``smart’’ variants,
e.g.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Quote</span> m <span class="ot">=&gt;</span> <span class="dt">Lit</span> <span class="ot">-&gt;</span> m <span class="dt">Exp</span></span></code></pre></div>
<p>so instead of <code>return (LitE (IntegerL 42))</code> we can write
<code>litE (IntegerL 42)</code></p>
<p>NB in recent versions we have</p>
<pre><code>[| \x -&gt; 1 |] :: Quote m =&gt; m Exp
instance Quote Q
instance Quote IO</code></pre>
<p>so that <code>runQ</code> is used less often, but the essence remains
the same.</p>
<h1 id="splicing-structure-trees-into-a-program-1">Splicing structure
trees into a program (1)</h1>
<pre><code>&gt; int = litE . IntegerL
&gt; $(int 42)
42

&gt; 1 + $(int 41)
42</code></pre>
<p>This allows for easy ``comptime’’, e.g.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span>(int (fib <span class="dv">20</span>))</span></code></pre></div>
<p>where <code>fib 20</code> is computed at compilation time.</p>
<p>(NB <code>int</code> and <code>fib</code> need to be in another
module)</p>
<h1 id="splicing-structure-trees-into-a-program-2">Splicing structure
trees into a program (2)</h1>
<p>Splicing and quoting can be interleaved:</p>
<pre><code>&gt; $(let x = [| 2 + 3 |] in [| 2 + $(x) |])
7

&gt; (let x = [| 2 + 3 |] in [| 2 + $(x) |]) &gt;&gt;= putStrLn . pprint
2 GHC.Num.+ (2 GHC.Num.+ 3)</code></pre>
<p>This allows to unroll recursion at comptime:</p>
<pre><code>power 0 = [| const 1 |]
power n = [| \k -&gt; k * $(power (n-1)) k |]

-- power 5 ~ \k -&gt; k * k * k * k * k * 1

-- &gt; $(power 5) 2
-- 32
</code></pre>
<h1 id="splicing-structure-trees-into-a-program-3">Splicing structure
trees into a program (3)</h1>
<pre><code>&gt; [| succ 1 |]
AppE (VarE GHC.Enum.succ) (LitE (IntegerL 1))
&gt; $(return it)
2</code></pre>
<p>but copying and pasting has its limits:</p>
<pre><code>&gt; $(return (AppE (VarE GHC.Enum.succ) (LitE (IntegerL 1))))

&lt;interactive&gt;: error:
    Couldn&#39;t match expected type ‘Name’ with actual type ‘a0 -&gt; a0’
    Probable cause: ‘succ’ is applied to too few arguments
    In the first argument of ‘VarE’, namely ‘succ’
    In the first argument of ‘AppE’, namely ‘(VarE succ)’

&gt; :t VarE
VarE :: Name -&gt; Exp

&gt; $(return (AppE (VarE &quot;GHC.Enum.succ&quot;) (LitE (IntegerL 1))))
&lt;interactive&gt;: error:
    • Couldn&#39;t match expected type ‘Name’ with actual type ‘[Char]’</code></pre>
<p><code>VarE</code> needs a <code>Name</code></p>
<pre><code>$(return (AppE (VarE &#39;succ) (LitE (IntegerL 1))))</code></pre>
<h1 id="making-a-name-from-string">Making a Name from String</h1>
<p><code>VarE</code> needs a <code>Name</code></p>
<pre><code>&gt; :t VarE
VarE :: Name -&gt; Exp

&gt; :t mkName
mkName :: String -&gt; Name

&gt; $(return (AppE (VarE (mkName &quot;succ&quot;)) (LitE (IntegerL 1))))
2

-- or $(appE (varE (mkName &quot;succ&quot;)) (litE (IntegerL 1)))</code></pre>
<h1 id="names-patterns-declarations">Names, patterns, declarations</h1>
<p>So far, we have been building expressions, but we can build patterns,
declarations, etc.:</p>
<pre><code>&gt; [d| p1 (a,b) = a |]
[FunD p1_0 [Clause [TupP [VarP a_1,VarP b_2]] (NormalB (VarE a_1)) []]]</code></pre>
<p><code>FunD</code> etc - see <a
href="https://hackage.haskell.org/package/template-haskell-2.16.0.0/docs/Language-Haskell-TH.html#g:18">documentation</a>.</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Clause</span> <span class="ot">=</span> <span class="dt">Clause</span> [<span class="dt">Pat</span>] <span class="dt">Body</span> [<span class="dt">Dec</span>]  <span class="co">-- f pats = b where decs</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Dec</span>                               <span class="co">-- declaration</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">FunD</span> <span class="dt">Name</span> [<span class="dt">Clause</span>]</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span></code></pre></div>
<p>Let us now try to build such a definition ourselves.</p>
<h1 id="stage-restriction">Stage restriction</h1>
<p>Note that we need to use two modules,<br /> since definitions to be
run during compilation have to be imported from a different module<br />
— the code to be run needs to be compiled first.</p>
<p>Otherwise you may see an error like</p>
<pre><code>GHC stage restriction:
      ‘build_p1’ is used in a top-level splice, quasi-quote, or annotation,
      and must be imported, not defined locally</code></pre>
<h1 id="build1">Build1</h1>
<div class="sourceCode" id="cb21"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Build1</span> <span class="kw">where</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Language.Haskell.TH</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- p1 (a,b) = a</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="ot">build_p1 ::</span> <span class="dt">Quote</span> m <span class="ot">=&gt;</span> m [<span class="dt">Dec</span>]</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>build_p1 <span class="ot">=</span> <span class="fu">return</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    [ <span class="dt">FunD</span> p1</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>             [ <span class="dt">Clause</span> [<span class="dt">TupP</span> [<span class="dt">VarP</span> a,<span class="dt">VarP</span> b]] (<span class="dt">NormalB</span> (<span class="dt">VarE</span> a)) []</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>             ]</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>    ] <span class="kw">where</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>       p1 <span class="ot">=</span> mkName <span class="st">&quot;p1&quot;</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>       a <span class="ot">=</span> mkName <span class="st">&quot;a&quot;</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>       b <span class="ot">=</span> mkName <span class="st">&quot;b&quot;</span></span></code></pre></div>
<div class="sourceCode" id="cb22"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Language.Haskell.TH</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Build1</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="op">$</span>(build_p1)</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> p1 (<span class="dv">1</span>,<span class="dv">2</span>)</span></code></pre></div>
<!-- [REPLit](https://replit.com/@mbenke/THProjections1) -->
<h1 id="printing-the-declarations-we-built">Printing the declarations we
built</h1>
<div class="sourceCode" id="cb23"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Build1</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Language.Haskell.TH</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="op">$</span>(build_p1)</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a><span class="ot">pprLn ::</span> <span class="dt">Ppr</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>pprLn <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="op">.</span> pprint</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- pprint :: Ppr a =&gt; a -&gt; String</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>  decs <span class="ot">&lt;-</span> build_p1</span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>  pprLn decs</span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> p1(<span class="dv">1</span>,<span class="dv">2</span>)</span></code></pre></div>
<pre><code>p1 (a, b) = a
1</code></pre>
<!--
Reminder about `runQ`:
``` {.haskell }
class Monad m => Quasi m where ...
instance Quasi Q where ...
instance Quasi IO where ...
runQ :: Quasi m => Q a -> m a
```
-->
<p>Reminder about the <code>Quote</code> class:</p>
<pre><code>class Monad m =&gt; Quote m where
  newName :: String -&gt; m Name

instance Quote Q -- Defined in ‘Language.Haskell.TH.Syntax’
instance Quote IO -- Defined in ‘Language.Haskell.TH.Syntax’</code></pre>
<h1 id="fresh-names">Fresh names</h1>
<p>Building and transforming structure trees for a language with
bindings is complicated because of possible name conflicts.</p>
<p>Luckily, TH provides the function <a
href="https://hackage.haskell.org/packages/archive/template-haskell/2.14.0.0/doc/html/Language-Haskell-TH.html#v:newName">newName</a>:</p>
<pre><code>newName :: String -&gt; Q Name

ghci&gt; runQ (mapM newName $ replicate 5 &quot;x&quot;)
[x_0,x_1,x_2,x_3,x_4]</code></pre>
<p>(which, by the way, explains one of the reasons why <a
href="https://hackage.haskell.org/packages/archive/template-haskell/2.14.0.0/doc/html/Language-Haskell-TH.html#t:Q">Q</a>
needs to be a monad).</p>
<p>Using <code>newName</code> we can safeguard our code against name
clashes.</p>
<p>Note, however, that <code>p1</code> is global and must use
<code>mkName</code>, while <code>a</code> and <code>b</code> are locals,
so we shall generate them using <code>newName</code>.</p>
<p>(in newer versions <code>newName</code> is a method of the
<code>Quote</code> class, but its essence remains the same)</p>
<pre><code>ghci&gt; newName &quot;&quot;
_0
ghci&gt; newName &quot;&quot;
_1</code></pre>
<h1 id="build2">Build2</h1>
<div class="sourceCode" id="cb28"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Build2</span> <span class="kw">where</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Language.Haskell.TH</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="ot">build_p1 ::</span> <span class="dt">Quote</span> m <span class="ot">=&gt;</span> m [<span class="dt">Dec</span>]</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>build_p1 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> p1 <span class="ot">=</span> mkName <span class="st">&quot;p1&quot;</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>  a <span class="ot">&lt;-</span> newName <span class="st">&quot;a&quot;</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>  b <span class="ot">&lt;-</span> newName <span class="st">&quot;a&quot;</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>    [ <span class="dt">FunD</span> p1</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>             [ <span class="dt">Clause</span> [<span class="dt">TupP</span> [<span class="dt">VarP</span> a, <span class="dt">VarP</span> b]] (<span class="dt">NormalB</span> (<span class="dt">VarE</span> a)) []</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>             ]</span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>    ]</span></code></pre></div>
<div class="sourceCode" id="cb29"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Language.Haskell.TH</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Build2</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a><span class="op">$</span>(build_p1)</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>  build_p1 <span class="op">&gt;&gt;=</span> <span class="fu">putStrLn</span> <span class="op">.</span> pprint</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> p1(<span class="dv">1</span>,<span class="dv">2</span>)</span></code></pre></div>
<!-- [REPLit](https://replit.com/@mbenke/THprojections2) -->
<h1 id="typical-th-use">Typical TH use</h1>
<p>Let us define all projections for large (say 8-) tuples. Writing this
by hand is no fun, but TH helps avoid the boilerplate.</p>
<p>Here we start by pairs, but extending it to larger tuples is a simple
exercise.</p>
<p>An auxiliary function building a simple declaration may come handy,
e.g.</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>simpleFun name pats rhs <span class="ot">=</span> <span class="dt">FunD</span> name [<span class="dt">Clause</span> pats (<span class="dt">NormalB</span> rhs) []]</span></code></pre></div>
<p>Given a function such that <code>build_p n</code> builds the nth
projection, we can build them all using <code>mapM</code></p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>build_ps <span class="ot">=</span> <span class="fu">mapM</span> build_p [<span class="dv">1</span>,<span class="dv">2</span>]</span></code></pre></div>
<p>Then we may splice the definitions into the program</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="op">$</span>(build_ps)</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">mapM_</span> <span class="fu">print</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>  [ p2_1 (<span class="dv">1</span>,<span class="dv">2</span>)</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>  , p2_2 (<span class="dv">1</span>,<span class="dv">2</span>)</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>  ]</span></code></pre></div>
<h1 id="build3">Build3</h1>
<div class="sourceCode" id="cb33"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Build3</span> <span class="kw">where</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Language.Haskell.TH</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="ot">simpleFun ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> [<span class="dt">Pat</span>] <span class="ot">-&gt;</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Dec</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>simpleFun name pats rhs <span class="ot">=</span> <span class="dt">FunD</span> name [<span class="dt">Clause</span> pats (<span class="dt">NormalB</span> rhs) []]</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>build_ps <span class="ot">=</span> <span class="fu">mapM</span> build_p [<span class="dv">1</span>,<span class="dv">2</span>] <span class="kw">where</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>    fname n <span class="ot">=</span> mkName <span class="op">$</span> <span class="st">&quot;p2_&quot;</span> <span class="op">++</span> <span class="fu">show</span> n</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>    build_p n <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>        argNames <span class="ot">&lt;-</span> <span class="fu">mapM</span> newName (<span class="fu">replicate</span> <span class="dv">2</span> <span class="st">&quot;a&quot;</span>)</span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> args <span class="ot">=</span> <span class="fu">map</span> <span class="dt">VarP</span> argNames</span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>        <span class="fu">return</span> <span class="op">$</span> simpleFun (fname n) [<span class="dt">TupP</span> args] (<span class="dt">VarE</span> (argNames <span class="op">!!</span> (n<span class="op">-</span><span class="dv">1</span>)))</span></code></pre></div>
<div class="sourceCode" id="cb34"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Build3</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>build_ps <span class="co">-- one may omit $(...) for declarations</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">mapM_</span> <span class="fu">print</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>    [ p2_1 (<span class="dv">1</span>,<span class="dv">2</span>)</span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>    , p2_2 (<span class="dv">1</span>,<span class="dv">2</span>)</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>    ]</span></code></pre></div>
<!-- [REPLit](https://replit.com/@mbenke/THProjections3) -->
<h1 id="quote-eval-quasiquote">Quote, eval, quasiquote</h1>
<p>In Lisp we have quote: <code>'</code> (<code>code -&gt; data</code>)
and eval (data -&gt; code):</p>
<pre><code>(+ 1 1)         =&gt; 2
&#39;(+ 1 1)        =&gt; (list &#39;+ 1 1)
(eval &#39;(+ 1 1)) =&gt; 2
(1 2 3)         ERROR
&#39;(1 2 3)        =&gt; (list 1 2 3)
&#39;(1 (+ 1 1) 3)  =&gt; (list 1 &#39;(+ 1 1) 3)</code></pre>
<p>and a slightly more involved quasiquote/unquote pair:
<code>`/,</code> (backtick/comma)</p>
<pre><code>`(1 ,(+ 1 1) 3) =&gt; (list 1 2 3)</code></pre>
<p>enabling us to evaluate some fragments inside quoted code.</p>
<p>In Lisp there are only S-expressions, Haskell syntax is more
complex:</p>
<ul>
<li>expressions</li>
<li>patterns</li>
<li>types</li>
<li>declarations</li>
</ul>
<h1 id="quasiquoting">Quasiquoting</h1>
<p>We have seen the standard quasiquoters e, t, d, p
(e.g. <code>[e| \x -&gt; x +1|]</code> ). We can also define our
own:</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>longString <span class="ot">=</span> [str|This is a multiline string.</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>It contains embedded newlines. And Unicode:</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>Ἐν ἀρχῇ ἦν ὁ Λόγος</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>It ends here: |]</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">putStrLn</span> longString</span></code></pre></div>
<div class="sourceCode" id="cb38"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Str</span>(str) <span class="kw">where</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Language.Haskell.TH</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Language.Haskell.TH.Quote</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>str <span class="ot">=</span> <span class="dt">QuasiQuoter</span> { quoteExp <span class="ot">=</span> stringE }</span></code></pre></div>
<ul>
<li><code>stringE</code> builds a string literal expression
(<code>stringE :: String -&gt; Q Exp</code>)</li>
<li><code>str</code> quasiquoter, when used in expression context,
splices this literal</li>
</ul>
<h1 id="the-quasiquoter-type">The QuasiQuoter type</h1>
<pre><code>&gt; :i QuasiQuoter
data QuasiQuoter
  = QuasiQuoter {quoteExp :: String -&gt; Q Exp,
                 quotePat :: String -&gt; Q Pat,
                 quoteType :: String -&gt; Q Type,
                 quoteDec :: String -&gt; Q [Dec]}
    -- Defined in ‘Language.Haskell.TH.Quote’</code></pre>
<div class="sourceCode" id="cb40"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>str <span class="ot">=</span> <span class="dt">QuasiQuoter</span> { quoteExp <span class="ot">=</span> stringE }</span></code></pre></div>
<p>We intend to use <code>str</code> only in expression contexts, so we
leave the other parts undefined.</p>
<h1 id="parsing-expressions">Parsing Expressions</h1>
<p>Let’s start with a simple data type and parser for arithmetic
expressions</p>
<div class="sourceCode" id="cb41"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveDataTypeable #-}</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span> <span class="ot">=</span> <span class="dt">EInt</span> <span class="dt">Int</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">EVar</span> <span class="dt">Var</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">EAdd</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">ESub</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">EMul</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">EDiv</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span>(<span class="dt">Show</span>,<span class="dt">Typeable</span>,<span class="dt">Data</span>)</span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- deriving Data needed to use generic function</span></span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a><span class="co">-- liftData :: Data a =&gt; a -&gt; ExpQ</span></span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a><span class="ot">pExpr ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a><span class="co">-- ...</span></span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true" tabindex="-1"></a>test1 <span class="ot">=</span> parse pExpr <span class="st">&quot;test1&quot;</span> <span class="st">&quot;1 - 2 - 3 * 4 &quot;</span></span>
<span id="cb41-17"><a href="#cb41-17" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> test1</span></code></pre></div>
<pre><code>Right (ESub (ESub (EInt 1) (EInt 2)) (EMul (EInt 3) (EInt 4)))</code></pre>
<h1 id="building-test-cases">Building test cases</h1>
<p>Now let’s say we need some expresion trees in our program. For this
kind of expressions we could (almost) get by with <code>class Num</code>
hack:</p>
<div class="sourceCode" id="cb43"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Expr</span> <span class="kw">where</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fromInteger</span> <span class="ot">=</span> <span class="dt">EInt</span> <span class="op">.</span> <span class="fu">fromInteger</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>  (<span class="op">+</span>) <span class="ot">=</span> <span class="dt">EAdd</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>  (<span class="op">*</span>) <span class="ot">=</span> <span class="dt">EMul</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>  (<span class="op">-</span>) <span class="ot">=</span> <span class="dt">ESub</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a><span class="ot">testExpr ::</span> <span class="dt">Expr</span></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>testExpr <span class="ot">=</span> (<span class="dv">2</span> <span class="op">+</span> <span class="dv">2</span>) <span class="op">*</span> <span class="dv">3</span></span></code></pre></div>
<p>…but it is neither extensible nor, in fact, nice.</p>
<h1 id="building-test-cases-via-parsing">Building test cases via
parsing</h1>
<p>Of course as soon as we have a parser ready we could use it to build
expressions</p>
<div class="sourceCode" id="cb44"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>testExpr <span class="ot">=</span> parse pExpr <span class="st">&quot;testExpr&quot;</span> <span class="st">&quot;1+2*3&quot;</span></span></code></pre></div>
<p>…but then potential errors in the expression texts remain undetected
until runtime, and also this is not flexible enough: what if we wanted a
simplifier for expressions, along the lines of</p>
<div class="sourceCode" id="cb45"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="ot">simpl ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>simpl (<span class="dt">EAdd</span> (<span class="dt">EInt</span> <span class="dv">0</span>) x) <span class="ot">=</span> x</span></code></pre></div>
<p>wouldn’t it be nice to be able to write this instead:</p>
<div class="sourceCode" id="cb46"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>simpl (<span class="dv">0</span> <span class="op">+</span> x) <span class="ot">=</span> x</span></code></pre></div>
<h1 id="building-test-cases-with-th">Building test cases with TH</h1>
<p>Using TH seemingly makes matters only worse:</p>
<div class="sourceCode" id="cb47"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="ot">testExpr ::</span> <span class="dt">Expr</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>testExpr <span class="ot">=</span> <span class="op">$</span>(<span class="fu">return</span> <span class="op">$</span> mkAdd (mkInt <span class="dv">0</span>) (mkInt <span class="dv">2</span>))</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a><span class="ot">simpl ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>simpl <span class="op">$</span>(<span class="fu">return</span> <span class="op">$</span> mkAddP (mkIntP <span class="dv">0</span>) (<span class="dt">VarP</span> (mkName <span class="st">&quot;x&quot;</span>))) <span class="ot">=</span> x</span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a><span class="ot">mkIntP ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Pat</span></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>mkIntP i <span class="ot">=</span> <span class="dt">ConP</span> (mkName <span class="st">&quot;EInt&quot;</span>) [<span class="dt">LitP</span> <span class="op">$</span> <span class="dt">IntegerL</span> i]</span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a><span class="ot">mkBinP ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Pat</span> <span class="ot">-&gt;</span> <span class="dt">Pat</span> <span class="ot">-&gt;</span> <span class="dt">Pat</span></span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a>mkBinP s p1 p2 <span class="ot">=</span> <span class="dt">ConP</span> (mkName s) [p1, p2]</span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a><span class="ot">mkAddP ::</span> <span class="dt">Pat</span> <span class="ot">-&gt;</span> <span class="dt">Pat</span> <span class="ot">-&gt;</span> <span class="dt">Pat</span></span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a>mkAddP <span class="ot">=</span> mkBinP <span class="st">&quot;EAdd&quot;</span></span></code></pre></div>
<p>…but there’s a better way</p>
<h1 id="why-its-good-to-be-quasiquoted">Why it’s Good to be
Quasiquoted</h1>
<p>what if we could instead write</p>
<div class="sourceCode" id="cb48"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="ot">simpl ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>simpl (<span class="dv">0</span> <span class="op">+</span> x) <span class="ot">=</span> x</span></code></pre></div>
<p>turns out with quasiquotation we can do just that (albeit with a
slightly different syntax), so to whet your appetite:</p>
<div class="sourceCode" id="cb49"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="ot">simpl ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>simpl [expr|0 + $x|] <span class="ot">=</span> x</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> simpl [expr|0+2|]</span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- ...</span></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a><span class="ot">expr  ::</span> <span class="dt">QuasiQuoter</span></span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>expr  <span class="ot">=</span>  <span class="dt">QuasiQuoter</span></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a>  { quoteExp <span class="ot">=</span> quoteExprExp</span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a>  , quotePat <span class="ot">=</span> quoteExprPat</span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>Let us start with the (perhaps simplest) quasiquoter for
expressions:</p>
<div class="sourceCode" id="cb50"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="ot">quoteExprExp ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Exp</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>quoteExprExp s <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>  pos <span class="ot">&lt;-</span> getPosition</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">exp</span> <span class="ot">&lt;-</span> parseExp pos s</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>  exprToExpQ <span class="fu">exp</span></span></code></pre></div>
<h1 id="quasiquoting-expressions">Quasiquoting Expressions</h1>
<p>There are three steps:</p>
<ul>
<li>record the current position in Haskell file (for parse error
reporting);</li>
<li>parse the expression into our abstract syntax;</li>
<li>convert our abstract syntax to its Template Haskell
representation.</li>
</ul>
<p>The first step is accomplished using <a
href="http://hackage.haskell.org/packages/archive/template-haskell/2.14.0.0/doc/html/Language-Haskell-TH.html#v:location">Language.Haskell.TH.location</a>
and converting it to something usable by Parsec:</p>
<div class="sourceCode" id="cb51"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>getPosition <span class="ot">=</span> <span class="fu">fmap</span> transPos location <span class="kw">where</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>  transPos loc <span class="ot">=</span> (loc_filename loc,</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>                  <span class="fu">fst</span> (loc_start loc),</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>                  <span class="fu">snd</span> (loc_start loc))</span></code></pre></div>
<p>Parsing is done with our expression parser, but building the Haskell
AST is a bit of work.</p>
<h1 id="building-ast">Building AST</h1>
<p>Next we need to build Haskell AST from expression tree built by our
parser:</p>
<div class="sourceCode" id="cb52"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="ot">exprToExpQ ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Exp</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>exprToExpQ (<span class="dt">EInt</span> n) <span class="ot">=</span> <span class="fu">return</span> <span class="op">$</span> <span class="dt">ConE</span> (mkName <span class="st">&quot;EInt&quot;</span>) <span class="op">$$</span> (intLitE n)</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>exprToExpQ (<span class="dt">EAdd</span> e1 e2) <span class="ot">=</span> convertBinE <span class="st">&quot;EAdd&quot;</span> e1 e2</span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>exprToExpQ (<span class="dt">ESub</span> e1 e2) <span class="ot">=</span> convertBinE <span class="st">&quot;ESub&quot;</span> e1 e2</span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>exprToExpQ (<span class="dt">EMul</span> e1 e2) <span class="ot">=</span> convertBinE <span class="st">&quot;EMul&quot;</span> e1 e2</span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>exprToExpQ (<span class="dt">EDiv</span> e1 e2) <span class="ot">=</span> convertBinE <span class="st">&quot;EDiv&quot;</span> e1 e2</span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a>convertBinE s e1 e2 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a>  e1&#39; <span class="ot">&lt;-</span> exprToExpQ e1</span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a>  e2&#39; <span class="ot">&lt;-</span> exprToExpQ e2</span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> <span class="dt">ConE</span> (mkName s) <span class="op">$$</span> e1&#39; <span class="op">$$</span> e2&#39;</span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-13"><a href="#cb52-13" aria-hidden="true" tabindex="-1"></a>(<span class="op">$$</span>) <span class="ot">=</span> <span class="dt">AppE</span>  <span class="co">-- TH AST node for application</span></span></code></pre></div>
<p>(alternatively we might make our parser return Haskell AST)</p>
<h1 id="scrap-your-boilerplate">Scrap Your Boilerplate</h1>
<p>This seems like a lot of boilerplate, luckily we can save us some
work use facilities for generic programming provided by <a
href="http://hackage.haskell.org/package/base/docs/Data-Data.html">Data.Data</a>
combined with the Template Haskell function <a
href="http://hackage.haskell.org/package/template-haskell-2.20.0.0/docs/Language-Haskell-TH-Syntax.html#v:dataToExpQ"><code>dataToExpQ</code></a>,</p>
<div class="sourceCode" id="cb53"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a> exprToExpQ <span class="ot">=</span>  dataToExpQ (<span class="fu">const</span> <span class="dt">Nothing</span>) <span class="fu">exp</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- dataToExpQ :: Data a</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a><span class="co">--            =&gt; (forall b. Data b =&gt; b -&gt; Maybe (Q Exp))</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a><span class="co">--            -&gt; a -&gt; Q Exp</span></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- the first argument provides a way of extending the translation</span></span></code></pre></div>
<p>or a simpler <a
href="https://hackage.haskell.org/package/template-haskell-2.20.0.0/docs/Language-Haskell-TH-Syntax.html#v:liftData">liftData</a></p>
<div class="sourceCode" id="cb54"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="ot">liftData ::</span> <span class="dt">Data</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Exp</span></span></code></pre></div>
<h1 id="data.data.data">Data.Data.Data</h1>
<p>To use <code>dataToExpQ</code> or <code>liftData</code> we need a
<code>Data.Data.Data</code> instance for <code>Expr</code>.</p>
<p>This would be total bolerplate, luckily it can be derived:</p>
<div class="sourceCode" id="cb55"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveDataTypeable #-}</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Expr</span> <span class="kw">where</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Typeable</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Data</span></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span> <span class="ot">=</span> <span class="dt">EInt</span> <span class="dt">Int</span></span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>         <span class="op">|</span> <span class="dt">EAdd</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a>         <span class="op">|</span> <span class="dt">ESub</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a>         <span class="op">|</span> <span class="dt">EMul</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a>         <span class="op">|</span> <span class="dt">EDiv</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a>           <span class="kw">deriving</span>(<span class="dt">Show</span>,<span class="dt">Typeable</span>,<span class="dt">Data</span>)</span></code></pre></div>
<h1 id="quasiquoting-patterns">Quasiquoting patterns</h1>
<p>So far, we are halfway through to our goal: we can use the
quasiquoter on the right hand side of function definitions:</p>
<div class="sourceCode" id="cb56"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="ot">testExpr ::</span> <span class="dt">Expr</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>testExpr <span class="ot">=</span> [expr|1+2*3|]</span></code></pre></div>
<p>To be able to write things like</p>
<div class="sourceCode" id="cb57"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>simpl [expr|0 + $x|] <span class="ot">=</span> x</span></code></pre></div>
<p>we need to write a quasiquoter for patterns.</p>
<h1 id="quasiquoting-constant-patterns">Quasiquoting constant
patterns</h1>
<p>Let us start with something less ambitious - a quasiquoter for
constant patterns, allowing us to write</p>
<div class="sourceCode" id="cb58"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="ot">testExpr ::</span> <span class="dt">Expr</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>testExpr <span class="ot">=</span> [expr|1+2*3|]</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a><span class="ot">f1 ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>f1 [expr| 1 + 2*3 |] <span class="ot">=</span> <span class="st">&quot;Bingo!&quot;</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>f1 _ <span class="ot">=</span> <span class="st">&quot;Sorry, no bonus&quot;</span></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="op">$</span> f1 testExpr</span></code></pre></div>
<p>This can be done similarly to the quasiquoter for expressions:</p>
<ul>
<li>record the current position in Haskell file (for parse error
reporting);</li>
<li>parse the expression into our abstract syntax;</li>
<li>convert our abstract syntax to its Template Haskell
representation.</li>
</ul>
<h1 id="building-pattern-ast">Building pattern AST</h1>
<p>This time we need to construct Template Haskell pattern
representation:</p>
<div class="sourceCode" id="cb59"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="ot">quoteExprPat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Pat</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>quoteExprPat s <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>  pos <span class="ot">&lt;-</span> getPosition</span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">exp</span> <span class="ot">&lt;-</span> parseExpr pos s</span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>  dataToPatQ (<span class="fu">const</span> <span class="dt">Nothing</span>) <span class="fu">exp</span></span></code></pre></div>
<p>The functions <code>quoteExprExp</code> and <code>quoteExprPat</code>
differ in two respects:</p>
<ul>
<li>use <code>dataToPatQ</code> instead of <code>dataToExpQ</code></li>
<li>the result type is different (obviously)</li>
</ul>
<h1 id="antiquotation">Antiquotation</h1>
<p>The quasiquotation mechanism we have seen so far allows us to
translate domain-specific code into Haskell and “inject” it into our
program.</p>
<p>Antiquotation, as the name suggests goes in the opposite direction:
embeds Haskell entities (e.g. variables) in our DSL.</p>
<p>This sounds complicated, but isn’t really. Think HTML templates:</p>
<div class="sourceCode" id="cb60"><pre
class="sourceCode html"><code class="sourceCode html"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">html</span><span class="dt">&gt;</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">head</span><span class="dt">&gt;</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">title</span><span class="dt">&gt;</span>#{pageTitle}</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">body</span><span class="dt">&gt;&lt;</span><span class="kw">h1</span><span class="dt">&gt;</span>#{pageTitle}</span></code></pre></div>
<p>The meaning is hopefully obvious — the value of program variable
<code>pageTitle</code> should be embedded in the indicated places. In
our expression language we might want to write</p>
<pre><code>twice :: Expr -&gt; Expr
twice e = [expr| $e + $e |]

testTwice = twice [expr| 3 * 3|]</code></pre>
<p>This is nothing revolutionary.</p>
<p>Haskell however, uses variables not only in expressions, but also in
patterns, and here the story becomes a little interesting.</p>
<h1 id="extending-quasiquoters">Extending quasiquoters</h1>
<p>Recall the pattern quasiquoter:</p>
<div class="sourceCode" id="cb62"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="ot">quoteExprPat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Pat</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>quoteExprPat s <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>  pos <span class="ot">&lt;-</span> getPosition</span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">exp</span> <span class="ot">&lt;-</span> parseExpr pos s</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>  dataToPatQ (<span class="fu">const</span> <span class="dt">Nothing</span>) <span class="fu">exp</span></span></code></pre></div>
<p>The <code>(const Nothing)</code> is a placeholder for extensions to
the standard <code>Data</code> to <code>Pat</code> translation:</p>
<div class="sourceCode" id="cb63"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="ot">quoteExprPat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Pat</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>quoteExprPat s <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>  pos <span class="ot">&lt;-</span> getPosition</span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">exp</span> <span class="ot">&lt;-</span> Expr.parseExpr pos s</span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>  dataToPatQ (<span class="fu">const</span> <span class="dt">Nothing</span> <span class="ot">`extQ`</span> antiExprPat) <span class="fu">exp</span></span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a><span class="ot">antiExprPat ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Q</span> <span class="dt">Pat</span>)</span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a>antiExprPat (<span class="dt">EMetaVar</span> v) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> varP (mkName v)</span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a>antiExprPat _ <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>What are the “extensions”?</p>
<h1 id="whats-a-function-extension">What’s a function extension?</h1>
<p>You have</p>
<ul>
<li>a generic function, say</li>
</ul>
<pre><code>gen :: Data a =&gt; a -&gt; R</code></pre>
<ul>
<li>a type-specific function, say</li>
</ul>
<pre><code>spec :: T -&gt; R</code></pre>
<p>You want a generic function which behaves like spec on values of type
T, and like gen on all other values.</p>
<p>The function <code>extQ</code> does just that.</p>
<pre><code>extQ :: (Typeable a, Typeable t) =&gt; (a -&gt; r) -&gt; (t -&gt; r) -&gt; a -&gt; r

gen `extQ` spec :: Data a =&gt; a -&gt; R  -- Data is a subclass of Typeable</code></pre>
<p>(NB <code>extQ</code> comes from <code>Data.Generics</code> and the
<code>Q</code> in the name has nothing to do with Template Haskell
<code>Q</code> monad)</p>
<h1 id="extending-datatopatq">Extending <code>dataToPatQ</code></h1>
<pre><code>const Nothing :: b -&gt; Maybe (Q Pat)

extQ :: (Data a, Data t) =&gt; (a -&gt; r) -&gt; (t -&gt; r) -&gt; a -&gt; r
-- specialized to Data

antiExprPat :: Expr -&gt; Maybe (Q Pat)

const Nothing `extQ` antiExprPat :: forall b.Data b =&gt; b -&gt; Maybe (Q Pat)

dataToPatQ
  :: Data a =&gt;
     (forall b.Data b =&gt; b -&gt; Maybe (Q Pat)) -&gt; a -&gt; Q Pat
-- specialized To Expr
-- :: (forall b.Data b =&gt; b -&gt; Maybe (Q Pat)) -&gt; Expr -&gt; Q Pat

dataToPatQ (const Nothing `extQ` antiExprPat) :: Expr -&gt; Q Pat</code></pre>
<h1 id="metavariables">Metavariables</h1>
<p>Let us extend our expression syntax and parser with metavariables
(variables from the metalanguage):</p>
<div class="sourceCode" id="cb68"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span> <span class="ot">=</span>  <span class="op">...</span> <span class="op">|</span> <span class="dt">EMetaVar</span> <span class="dt">String</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>           <span class="kw">deriving</span>(<span class="dt">Show</span>,<span class="dt">Typeable</span>,<span class="dt">Data</span>)</span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a><span class="ot">pExpr ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>pExpr <span class="ot">=</span> pTerm <span class="ot">`chainl1`</span> spaced addop</span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a>pTerm <span class="ot">=</span> spaced pFactor <span class="ot">`chainl1`</span> spaced mulop</span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a>pFactor <span class="ot">=</span> pNum <span class="op">&lt;|&gt;</span> pMetaVar</span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-10"><a href="#cb68-10" aria-hidden="true" tabindex="-1"></a>pMetaVar <span class="ot">=</span> char <span class="ch">&#39;$&#39;</span> <span class="op">&gt;&gt;</span> <span class="dt">EMetaVar</span> <span class="op">&lt;$&gt;</span> ident</span>
<span id="cb68-11"><a href="#cb68-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-12"><a href="#cb68-12" aria-hidden="true" tabindex="-1"></a>test1 <span class="ot">=</span> parse pExpr <span class="st">&quot;test1&quot;</span> <span class="st">&quot;1 - 2 - 3 * 4 &quot;</span></span>
<span id="cb68-13"><a href="#cb68-13" aria-hidden="true" tabindex="-1"></a>test2 <span class="ot">=</span> parse pExpr <span class="st">&quot;test2&quot;</span> <span class="st">&quot;$x - $y*$z&quot;</span></span>
<span id="cb68-14"><a href="#cb68-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-15"><a href="#cb68-15" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> test1</span>
<span id="cb68-16"><a href="#cb68-16" aria-hidden="true" tabindex="-1"></a><span class="dt">Right</span> (<span class="dt">ESub</span> (<span class="dt">ESub</span> (<span class="dt">EInt</span> <span class="dv">1</span>) (<span class="dt">EInt</span> <span class="dv">2</span>)) (<span class="dt">EMul</span> (<span class="dt">EInt</span> <span class="dv">3</span>) (<span class="dt">EInt</span> <span class="dv">4</span>)))</span>
<span id="cb68-17"><a href="#cb68-17" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> test2</span>
<span id="cb68-18"><a href="#cb68-18" aria-hidden="true" tabindex="-1"></a><span class="dt">Right</span> (<span class="dt">ESub</span> (<span class="dt">EMetaVar</span> <span class="st">&quot;x&quot;</span>) (<span class="dt">EMul</span> (<span class="dt">EMetaVar</span> <span class="st">&quot;y&quot;</span>) (<span class="dt">EMetaVar</span> <span class="st">&quot;z&quot;</span>)))</span></code></pre></div>
<h1 id="antiquoting-metavariables">Antiquoting metavariables</h1>
<p>The antiquoter is defined as an extension for the
<code>dataToPatQ</code>:</p>
<div class="sourceCode" id="cb69"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="ot">antiExprPat ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Q</span> <span class="dt">Pat</span>)</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>antiExprPat (<span class="dt">EMetaVar</span> v) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> varP (mkName v)</span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>antiExprPat _ <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<ul>
<li>metavariables are translated to <code>Just</code> TH variables</li>
<li>for all the other cases we say <code>Nothing</code> - allowing
<code>dataToPatQ</code> use its default rules</li>
</ul>
<p>And that’s it! Now we can write</p>
<div class="sourceCode" id="cb70"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>eval [expr| $a + $b|] <span class="ot">=</span> eval a <span class="op">+</span> eval b</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>eval [expr| $a * $b|] <span class="ot">=</span> eval a <span class="op">*</span> eval b</span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">EInt</span> n) <span class="ot">=</span> n</span></code></pre></div>
<h1 id="bnfc-meta">bnfc-meta</h1>
<p>Instead of writing a parser by hand, we can use BNFC.</p>
<p>Similarly we can use <code>bnfc-meta</code> to generate
quasiquoters:</p>
<div class="sourceCode" id="cb71"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Expr</span> <span class="kw">where</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Language.LBNF.Compiletime</span></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Language.LBNF</span>(lbnf, bnfc)</span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a>bnfc [lbnf|</span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a>EAdd . Expr1 ::= Expr1 &quot;+&quot; Expr2 ;</span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a>EMul . Expr2 ::= Expr2 &quot;*&quot; Expr3 ;</span>
<span id="cb71-8"><a href="#cb71-8" aria-hidden="true" tabindex="-1"></a>ELit . Expr3 ::= Integer ;</span>
<span id="cb71-9"><a href="#cb71-9" aria-hidden="true" tabindex="-1"></a>EVar . Expr3 ::= Ident ;</span>
<span id="cb71-10"><a href="#cb71-10" aria-hidden="true" tabindex="-1"></a>coercions Expr 3;</span>
<span id="cb71-11"><a href="#cb71-11" aria-hidden="true" tabindex="-1"></a>|]</span>
<span id="cb71-12"><a href="#cb71-12" aria-hidden="true" tabindex="-1"></a><span class="co">------------------------------------------------------------------</span></span>
<span id="cb71-13"><a href="#cb71-13" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Expr</span></span>
<span id="cb71-14"><a href="#cb71-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-15"><a href="#cb71-15" aria-hidden="true" tabindex="-1"></a><span class="ot">exp1 ::</span> <span class="dt">Expr</span></span>
<span id="cb71-16"><a href="#cb71-16" aria-hidden="true" tabindex="-1"></a>exp1 <span class="ot">=</span> [expr| 2 + 2 |]</span></code></pre></div>
<h1 id="exercises">Exercises</h1>
<ul>
<li>Write a function such that <code>build_ps n</code> generates all
projections for n-tuples,</li>
<li>Write a function <code>tupleFromList</code> such that</li>
</ul>
<pre><code>$(tupleFromList 8) [1..8] == (1,2,3,4,5,6,7,8)</code></pre>
<ul>
<li>W rite a <code>matrix</code> quasiquoter such that</li>
</ul>
<pre><code>*MatrixSplice&gt; :{
*MatrixSplice| [matrix|
*MatrixSplice| 1 2
*MatrixSplice| 3 4
*MatrixSplice| |]
*MatrixSplice| :}
[[1,2],[3,4]]</code></pre>
<p>be careful with blank lines!</p>
<ul>
<li><p>Extend the expression simplifier with more rules.</p></li>
<li><p>Extend the expression quasiquoter to handle metavariables for
numeric constants, allowing to implement simplification rules
like</p></li>
</ul>
<pre><code>simpl [expr|$int:n$ + $int:m$|] = [expr| $int:m+n$ |]</code></pre>
<p>(you are welcome to invent your own syntax in place of
<code>$int: ... $</code>)</p>
<ul>
<li>generate expression quasiquoters using <code>bnfc-meta</code></li>
</ul>
</body>
</html>
